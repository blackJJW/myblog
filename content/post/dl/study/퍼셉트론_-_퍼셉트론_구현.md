---
title: "[DL] 퍼셉트론 - 퍼셉트론 구현"
description: ""
date: "2023-03-24T22:00:45+09:00"
thumbnail: ""
categories:
  - "DL"
tags:
  - "DL"
  - "Python"
  - "NumPy"

---

<!--more-->

## 1. 간단한 구현

- 논리 회로를 Python으로 구현

1) $x_1$과 $x_2$를 인수로 받는 AND 함수

```python
def AND(x1, x2):
  w1, w2, theta = 0.5, 0.5, 0.7 # 매개변수 w1, w2, theta는 함수 안에서 초기화
  tmp = x1 * w1 + x2 * w2
  if tmp <= theta:  # 가중치를 곱한 입력의 총합이 임계값을 넘으면 1
    return 0        # 그 외에는 0을 반환
  elif tmp > theta:
    return 1
```

![Untitled](/images/DL/퍼셉트론_-_퍼셉트론_구현/Untitled.png)

## 2. 가중치와 편향 도입

$$
y=\begin{cases}0 &(w_1x_1+w_2x_2\le\theta) \\\\ 1 &(w_1x_1+w_2x_2\gt\theta) \end{cases}
$$

- $\theta$를 $-b$로 치환

$$
y=\begin{cases}0 &(b+w_1x_1+w_2x_2\le0) \\\\ 1 &(b+w_1x_1+w_2x_2\gt0) \end{cases}\\\\ *\ b : 편향\ \ bias \\\\ *\ w_1,\ w_2 : 가중치\ \ weight
$$

- 퍼셉트론은 입력 신호에 가중치를 곱한 값과 편향을 합한다.
    - 값이 0을 넘으면 1을 출력
    - 그렇지 않으면 0을 출력

1) NumPy를 사용하여 구현

```python
import numpy as np
x = np.array([0, 1])     # 입력
w = np.array([0.5, 0.5]) # 가중치
b = -0.7                 # 편향
```

![Untitled](/images/DL/퍼셉트론_-_퍼셉트론_구현/Untitled%201.png)

- 넘파이 배열끼리의 곱셈은 두 배열의 원소 수가 같다면 각 원소끼리 곱한다.
    - 위 예의 `w * x` 에서는 인덱스가 같은 원소끼리 곱한다.
    
    $$
    [0,\ 1]*[0.5,\ 0.5]\ \implies [0.,\ 0.5]
    $$
    
- `np.sum()` 메소드는 입력한 배열에 담긴 모든 원소의 총합을 계산
    - 이 가중치에 편향을 더하면 다음식 계산이 완료
    
    $$
    y=\begin{cases}0 &(b+w_1x_1+w_2x_2\le0) \\\\ 1 &(b+w_1x_1+w_2x_2\gt0) \end{cases}
    $$
    

## 3. 가중치와 편향 구현

1) ‘**가중치와 편향을 도입**’한 AND 게이트

```python
def AND(x1, x2):
  x = np.array([x1, x2])
  w = np.array([0.5, 0.5])
  b = -0.7
  tmp = np.sum(w * x) + b  # -θ가 편향 b로 치환
  if tmp <= 0:             # 편향은 가중치 w1, w1와 기능이 다르다.
    return 0
  elif tmp > 0:
    return 1
```

- $w_1$과 $w_2$ : 각 입력 신호가 결과에 주는 영향력(중요도)을 조절하는 매개 변수
- 편향 : 뉴런이 얼마나 쉽게 활성화(결과로 1을 출력) 하느냐를 조정하는 매개 변수

ex) $b$가 $-0.1$이면 각 입력 신호에 가중치를 곱한 값들의 합이 $0.1$을 초과할 때만 뉴런이 활성화

- 반면 $b$가 $-20.0$이면 각 입력 신호에 가중치를 곱한 값들의 합이 $20.0$을 넘지 않으면 뉴런은 활성화하지 않는다.
- 편향의 값은 뉴런이 얼마나 쉽게 활성화되는지 결정

> ***편향이라는 용어는 ‘한쪽으로 치우쳐 균형을 깬다’라는 의미
실제로 식 $y=\begin{cases}0 &(b+w_1x_1+w_2x_2\le0) \\\\ 1 &(b+w_1x_1+w_2x_2\gt0) \end{cases}$는 두 입력이 모두 0이어도 결과로 (0이 아닌) 편향 값을 출력***
> 

2) NAND 게이트와 OR 게이트

```python
def NAND(x1, x2):
  x = np.array([x1, x2])
  w = np.array([-0.5, -0.5]) # AND와는 가중치(w와 b)만 다름
  b = 0.7
  tmp = np.sum(w * x) + b
  if tmp <= 0:
    return 0
  elif tmp > 0:
    return 1

def OR(x1, x2):
  x = np.array([x1, x2])
  w = np.array([0.5, 0.5]) 
  b = -0.2                  # AND와는 가중치(w와 b)만 다름
  tmp = np.sum(w * x) + b
  if tmp <= 0:
    return 0
  elif tmp > 0:
    return 1
```

### ◎ AND, NAND, OR → 모두 같은 구조의 퍼셉트론

- 차이는 가중치 매개변수의 값

---

## References

- 밑바닥부터 시작하는 딥러닝 - 사이토 고치 지음, 한빛미디어 출판