---
title: "[Algorithm][Python] 알고리즘 분석"
description: ""
date: "2022-06-21T16:30:45+09:00"
thumbnail: ""
categories:
  - "Algorithm"
tags:
  - "Algorithm"
  - "Python"


---
<!--more-->

- 어떤 알고리즘에 대한 두 가지 중요한 질문
    - **정확한가?**
        - **모든 입력 사례**에 대해 **해답**을 찾을 수 있는 가?
    - **효율적인가?**
        - **입력 크기**가 커지면 **성능**은 어떻게 **변화**하는가?

## 알고리즘 분석

---

- **정확성 분석** : 모든 입력 사례에 대해서 정확한 해답을 찾는 것을 증명
    - 귀납적 증명
- **효율성 분석** : **입력 크기**가 커지는 정도에 따라 **성능의 변화량** 증명
    - **시간 복잡도**(**time complexity**)
        - **시간**을 기준으로 알고리즘의 효율성 분석
    - **공간 복잡도**(**space complexity**)
        - **공간**을 기준으로 알고리즘의 효율성 분석

## 알고리즘 성능 분석

---

- **퍼포먼스 측정** : 실행 시간을 직접 측정 or 실행 명령의 숫자 세기
    - **컴퓨터의 성능이나 프로그램 언어에 따라 달라짐**
- **복잡도 분석** : 컴퓨터나 프로그래밍 언어와 **무관하게 성능 분석**
    - **입력 크기**에 따른 **단위 연산의 실행 횟수 세기**

## 복잡도 분석

---

- **입력 크기**(**input size**) : 문제가 가진 파라미터, 즉 **입력 사례의 크기**
- **단위 연산**(**basic operation**) : 알고리즘 **실행의 기본이 되는 명령어들의 집합**

### 시간 복잡도 분석

- 배열 원소의 합
    
    ```python
    def sum(S):
    	n = len(S)
    	result = 0
    	for i in range(n): // 입력 크기 : n
    		result += S[i]   // 단위 연산 : 덧셈 연산
    	return result
    ```
    
    - **단위 연산** : 리스트의 원소를 result에 **더하는 명령**
    - **입력 크기** : 리스트 S의 **원소 개수**(**n**)
    - for 문장은 **항상 n번 실행**하므로 다음과 같이 표현
        - **시간 복잡도** : $T(n) =n$

- 교환 정렬
    
    ```python
    def exchange(S):
    	n = len(S)
    	for i in range(n - 1):    // 1. for문 n-1번 
    		for j in range(i + 1, n): // 2. for - i 루프에 따라 n-1번에서 1번까지 실행
    			if (S[i] > S[j]):   // 단위 연산
    				S[i], S[j] = S[j], S[i] # swap // 단위 연산 아님(조건문에 따라 연산 수행 유무)
    ```
    
    - **단위 연산** : S[i]와 S[j]의 **비교**
    - **입력 크기** : 정렬할 리스트 S의 **원소 개수**(**n**)
    - for - j루프는 i에 따라 n-1번에서 1번까지 실행
        - **시간 복잡도** : $T(n)=(n-1)+(n-2)+\cdots +1=\frac{(n-1)n}{2}$

-

- 행렬 곱셈
    
    ```python
    def matrixmult(A, B):
    	n = len(A)
    	C = [[0] * n for _ in range(n)] 
    	for i in range(n): // n 번
    		for j in range(n): // n 번
    			for k in range(n): // n 번
    				C[i][j] += A[i][k] * B[k][j]  // 곱셈 연산
    
    	return C
    ```
    
    - **단위 연산** : 가장 안쪽 for 루프에 있는 **곱셈**
    - **입력 크기** : **행과 열의 개수**(**n**)
    - **3중 for 루프가 항상 n번 실행**하므로 다음과 같이 계산
        - **시간 복잡도** : $T(n)=n \times n \times n=n^{3}$

-

### 단위 연산의 실행 횟수는 항상 일정한가?

- 알고리즘에 따라 **항상 일정한 경우**와 **입력 사례에 따라 다른 경우**가 존재

### 입력 사례에 따른 시간 복잡도 분석

- **일정** 시간 복잡도 : 입력 사례에 따라 달라지지 않는 경우
- **최악(worst-case), 최적(best-case), 평균(average-case)** 시간 복잡도 분석 : 입력 사례에 따라 달라지는 경우

- 순차 탐색
    
    ```python
    def seqsearch(n, S, x):
    	location = 1
    	while (location <= n and S[location] != x):
    		location += 1
    	if (location > n):
    		location = 0
    	return location
    ```
    
    - **단위 연산** : 리스트의 원소와 주어진 키 x와의 **비교 연산**
    - **입력 크기** : 리스트 **원소의 개수**(**n**)
    - **최악**의 경우는 **모두 비교** : $W(n)=n$
    - **최적**의 경우는 **한 번만 비교** : $B(n)=1$
    - **평균**의 경우 : 주어진 키 x가 k번째에 있으면 k번을 비교함
        - 만약 어떤 키 x는 리스트 S에 **골고루 분포**(**uniformly distribution**)해 있다면
        - $A(n)=\displaystyle\sum_{k=1}^{n}{(k\times\frac{1}{n})}=\frac{1}{n}\displaystyle\sum_{k=1}^{n}{k}=\frac{1}{n}\times\frac{n(n+1)}{2}=\frac{n+1}{2}$
            

## 알고리즘의 차수

---

### 어떤 알고리즘이 (궁극적으로) 더 빠른가?

- **시간 복잡도** : 입력 크기(n)에 대한 단위 연산 횟수의 함수 $f(n)$
- 시간 복잡도가 $f_{1}(n)=n$인 알고리즘과 $f_{2}(n)=n^{2}$인 알고리즘
- 만약 단위 연산의 실행 시간이 $f_{2}$는 $t$이고, $f_{1}$은 $1000t$일 경우
    - $f_1$의 단위 연산이 $f_2$의 단위 연산보다 1000배 느리지만
    - 알고리즘 전체 실행 시간은 $f_1$이 $n\times 1000t$, $f_2$는 $n^2 \times t$이므로
    - 부등식 $n^2 \times t \gt n \times 1000t$이 성립하려면
    - $n \gt 1000$
    - 즉 $n$이 1000보다 크면 $f_1$이 $f_2$보다 **궁극적으로 더 빠르다고 할 수 있다**.
    
- **차수(Order)** : 알고리즘의 궁극적인 **성능 분류**
    - **1차 시간 알고리즘** : 시간 복잡도가 1차 함수인 알고리즘
    - **2차 시간 알고리즘** : 시간 복잡도가 2차 함수인 알고리즘
    - **근본 원리** : 모든 1차 시간 알고리즘은 궁극적으로 2차 시간 알고리즘 보다 빠르다.
    - **시간 복잡도 함수의 차수**로 **알고리즘의 성능을 분류 가능**

### 자주 사용되는 복잡도 분류

|      복잡도 함수      |   분류 이름   |  대분류   |
|:----------------:|:---------:|:------:|
|        1         |   상수 시간   | 다항 시간  |
|  $\log_{2}{n}$   |   로그 시간   | 다항 시간  |
|       $n$        |   선형 시간   | 다항 시간  |
|  $n\log_{2}{n}$  | 선형-로그 시간  | 다항 시간  |
|      $n^2$       |   2차 시간   | 다항 시간  |
|      $n^3$       |   3차 시간   | 다항 시간  |
|      $2^n$       |   지수 시간   | 지수 시간  |
|       $n!$       |  팩토리얼 시간  | 지수 시간  |

### 알고리즘의 성능을 차수로 분류하는 법

- 복잡도 함수를 분류할 때 **낮은 차수의 항들은 항상 버릴 수 있다.**
- ex) $an^{2}+bn+c$의 함수를 2차 시간 함수($n^2$)로 분류
    - 궁극적으로 2차 항이 이 함수의 값을 결정하는 데 가장 중요하기 때문

### 점근적 표기법

- 빅오($O$) : 복잡도 함수의 **점근적 상한**을 표기
- 오메가($\Omega$) : 복잡도 함수의 **점근적 하한**을 표기
- 쎄타($\Theta$) : 복잡도 함수의 **점근적 상한과 하한을 동시에 만족**

- **교환 정렬의 차수**
    - $T(n) = \frac{n(n-1)}{2}=\frac{1}{2}n^{2}-\frac{1}{2}n$
    - $T(n) \in O(n^2), T(n)\in \Omega(n^2), T(n)\in \Theta(n^2)$
    - 교환 정렬 알고리즘의 차수는 $\Theta(n^2)$

- **순차 탐색의 차수**
    - **최악**의 경우 : $W(n)=n \in \Theta(n)$
    - 최적의 경우 : $B(n) = 1 \in \Theta(1)$
    - **평균**의 경우 : $A(n)=\frac{n+1}{2}\in \Theta(n)$

## References

- [inflearn] 파이썬으로 배우는 알고리즘 기초 - 강의자 : 주니온