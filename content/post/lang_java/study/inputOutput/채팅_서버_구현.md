---
title: "[Java] TCP 네트워킹, 채팅 서버 구현"
description: ""
date: "2023-01-22T21:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "JavaFX"
  - "Network"
---
<!--more-->

## 1. 서버 클래스 구조

- 서버 클래스의 구조
    - ServerEx.java
        - 채팅 서버
    
    ```java
    import java.net.ServerSocket;
    import java.util.List;
    import java.util.Vector;
    import java.util.concurrent.ExecutorService;
    
    import javafx.application.Application;
    
    // JavaFX 메인 클래스로 만들기 위해 Application을 상속 받음
    public class ServerEx extends Application {
    
    	// 스레드풀인 ExecutorService 필드가 선언
    	ExecutorService executorService;
    
    	// 클라이언트의 연결을 수락하는 ServiceSocket 필드가 선언
    	ServerSocket serverSocket;
    
    	/* 연결된 클라이언트를 저장하는 List<Client> 타입의 
    	 * connections 필드가 선언
    	 * 스레드에 안전한 Vector로 초기화
    	 */
    	List<Client> connections = new Vector<Client>();
    	
    	// startServer()는 서버 시작 시 호출되는 메소드
    	void startServer() { 
    		// 서버 시작 코드
    	}
    
    	// stopServer()는 서버 종료 시  호출되는 메소드
    	void stopServer() {
    		// 서버 종료 코드
    	}
    	
    	// Client 클래스는 연결된 클라이언트를 표현
    	// 데이터 통신 코드를 포함
    	class Client {
    		// 데이터 통신 코드
    	}
    	
    	//////////////////////////////////
    	// UI 생성 코드는 레이아웃을 구성하고 ServerEx을 실행
    	// UI 생성 코드
    }
    ```
    
- 실행 화면에서 [start] 버튼을 클릭하면 `startServer()` 메소드가 호출
    - [start] 버튼은 [stop] 버튼으로 변경
- [stop] 버튼을 클릭하면 `stopServer()` 메소드가 호출
    - [start] 버튼으로 변경

## 2. `startServer()` 메소드

- [start] 버튼을 클릭하면 `startServer()` 메소드가 실행
    - startServer() 메소드
        - ExecutorService 생성
        - ServerSocket 생성 및 포트 바인딩
        - 연결 수락 코드
    - ExecutorService 생성 코드
    
    ```java
    void startServer() {
    	/* ExecutorService 객체를 얻기 위해 
    	 * Executors.newFixedThreadPool() 메소드를 호출
    	 */
    	executorService = Executors.newFixedThreadPool(
    		// CPU 코어의 수만큼 스레드를 만들도록 한다.
    		Runtime.getRuntime().availableProcessors()
    	);
    }
    ```
    
    - ServerSocket 생성 및 포트 바인딩 코드
    
    ```java
    try {
    	// ServerSocket 객체를 생성
    	serverSocket = new ServerSocket();
    
    	// ServerSocket을 로컬 컴퓨터 5001 포트와 바인딩
    	serverSocket.bind(new InetSocketAddress("localhost", 5001));
    } catch(Exception e) {
    
    	/* 예외가 발생할 경우 ServerSocket이 닫혀있지 않으면 
    	 * stopServer() 메소드를 호출
    	 */
    	if(!serverSocket.isClosed()) { stopServer(); }
    
    	// startServer() 메소드를 종료
    	return;
    }
    ```
    
    - 연결을 수락하는 코드
    
    ```java
    // 연결 수락 작업을 Runnable로 정의
    Runnable runnable = new Runnable() { // 수락 작업 생성
    	// run() 메소드를 재정의
    	@Override
    	public void run() {
    		/* 작업 스레드는 UI를 변경하지 못하므로 
    		 * Platform.runLater()가 사용
    		 */
    		Platform.runLater(() -> {
    			// “[ 서버 시작 ]”을 출력하도록 displayText()를 호출
    			displayText("[ 서버 시작 ]");
    			// [start] 버튼의 글자를 [stop]으로 변경
    			btnStartStop.setText("stop");
    		});
    
    		// 클라이언트의 연결 수락을 무한히 반복
    		while(true) {
    			try {
    				/* 클라이언트의 연결 요청을 기다리고,
    				 * 연결 수락을 하는 accept() 메소드를 호출
    				 */
    				Socket socket = serverSocket.accept(); // 연결 수락
    				
    				/* 연결 수락이 되면 클라이언트 IP 주소와
    				 * 스레드 이름이 포함된 연결 수락 메시지 문자열을 
    				 * 만든다.
    				 */
    				String message = "[ 연결 수락 : " 
    								+ socket.getRemoteSocketAddress() 
    								+ ": " + Thread.currnetThread().getName() + " ]";
    				// 메시지를 출력하도록 displayText()를 호출
    				Platform.runLater(() -> displayText(message));
    						
    				// Client 객체 생성
    				Client client = new Client(socket);
    				// Client 객체를 connections 컬렉션에 추가
    				connections.add(client);
    			
    				/* connections 컬렉션에 저장된 Client 객체 수를
    				 * 출력하도록 displayText()를 호출
    				 */
    				Platform.runLater(() -> displayText("[ 연결 개수 : "
    												+ connections.size() + "]"));
    			} catch (Exception e) {
    
    				/* 예외가 발생했을 경우, ServerSockete이 닫혀있지
    				 * 않으면 stopServer()를 호출
    				 */
    				if(!serverSocket.isClosed()) { stopServer(); }
    
    				// break를 사용해서 while문을 멈춘다.
    				break;
    			}
    		}
    	}
    };
    /* 스레드풀의 작업 스레드에서 연결 수락 작업을 수락하기
     * 위해 submit()을 호출
     */
    executorService.submit(runnable); // 스레드풀에서 처리
    ```
    

## 3. `stopServer()` 메소드

- [stop] 버튼을 클릭하면 `stopServer()` 메소드가 실행
    - `stopServer()` 메소드
        - 연결된 모든 Socket 닫기
        - ServerSocket 닫기
        - ExecutorService 종료 코드
    
    ```java
    void stopServer() {
    	try {
    		// 모든 Socket 닫기
    		// connections 컬렉션으로부터 반복자를 얻음
    		Iterator<Client> iterator = connections.iterator();
    			
    		// while문으로 반복자를 반복
    		while(iterator.hasNext()) {
    			// 반복자로부터 Client를 하나씩 얻는다.
    			Client client = iterator.next();
    			// Client가 가지고 있는 Socket을 닫는다.
    			client.socket.close();
    			// connections 컬렉션에서 Client를 제거
    			iterator.remove();
    		}
    			
    		// ServerSocket 닫기
    		// ServerSocket이 null이 아니고, 닫혀있지 않으면
    		if(serverSocket != null && !serverSocket.isClosed()) {
    			// ServerSocket 닫음
    			serverSocket.close();
    		}
    			
    		// ExecutorService 종료
    		// ExecutorService가 null이 아니고, 종료 상태가 아니면
    		if(executorService != null && !executorService.isShutdown()) {
    			// ExecutorService 종료
    			executorService.shutdown();
    		}
    		// 작업 스레드는 UI를 변경하지 못하므로 Platfrom.runLater()가 사용됨
    		Platform.runLater(() -> {
    			// "[ 서버 멈춤 ]"을 출력하도록 displayText()를 호출
    			displayText("[ 서버 멈춤 ]");
    			// [stop] 버튼의 글자를 [start]로 변경
    			btnStartStop.setText("start");
    		});
    	} catch (Exception e) {}
    }
    ```
    

## 4. Client 클래스

- 서버에 다수의 클라이언트가 연결하기 때문에 서버는 클라이언트를 관리해야 한다.
- 클라이언트 별로 고유한 데이터를 저장할 필요도 있기 때문에 Client 클래스를 작성
    - 연결 수락 시마다 Client 인스턴스를 생성해서 관리하는 것이 좋다.
- Client 클래스의 구조
    
    ```java
    // Client를 ServerEx의 내부 클래스로 선언
    class Client {
    	// Socket 필드를 선언
    	Socket socket;
    		
    	// Client 생성자를 선언
    	Client(Socket socket){
    		// 매개값으로 받은 Socket을 필드값으로 저장
    		this.socket = socket;
    		// receive() 메소드를 호출
    		receive();
    	}
    		
    	// 데이터를 받기 위해 receive() 메소드를 선언
    	void receive() {
    		// 데이터 받기 코드
    	}
    		
    	// 데이터를 보내기 위해 send() 메소들르 선언
    	void send(String data) {
    		// 데이터 전송 코드
    	}
    }
    ```
    
- 클라이언트의 데이터를 받는 `receive()` 메소드 코드
    
    ```java
    // 데이터를 받기 위해 receive() 메소드를 선언
    void receive() {
    	// 받기 작업 생성
    	// 클라이언트로부터 데이터를 받는 작업을 Runnable로 정의
    	Runnable runnable = new Runnable() {
    		// run() 메소드를 재정의
    		@Override
    		public void run() {
    			try {
    				while(true) { // 작업을 무한히 반복
    					// 받은 데이터를 저장할 byte[] 배열인 byteArr를 생성
    					byte[] byteArr = new byte[100];
    					// Socket으로부터 InputStream을 얻는다.
    					InputStream inputStream = socket.getInputStream();
    							
    					// 클라이언트가 비정상 종료를 했을 경우 IOException 발생
    					// 데이터 받기
    					/* InputStream의 read() 메소드를 호출
    					 * 클라이언트가 데이터를 보내기 전까지 블로킹된다.
    					 * 데이터를 받으면 byteArr에 저장한 후 
    					 * 받은 바이트 개수를 readByteCount에 저장
    					 */
    					int readByteCount = inputStream.read(byteArr);
    							
    					/* 클라이언트가 정상적으로 Socket의 close()를 호출했을 경우
    					 * 위의 read() 메소드는 -1을 리턴
    					 * 이 경우 IOException을 강제로 발생시킨다.
    					 */
    					if(readByteCount == -1) { throw new IOException(); }
    							
    					/* 정상적으로 데이터를 받았을 경우
    					 * "[ 요청 처리 : 클라이언트 IP : 작업스레드이름]"으로 구성된 문자열 생성
    					 */
    					String message = "[ 요청 처리 : " + socket.getRemoteSocketAddress()
    									+ " : " + Thread.currentThread().getName() + " ]";
    							
    					// 문자열을 출력하도록 displayText()를 호출
    					Platform.runLater(() -> displayText(message));
    							
    					// 문자열로 변환
    					/* String(byteArr, 0, readByteCount, "UTF-8")을 이용해서
    					 * UTF-8로 디코딩한 문자열을 얻는다.
    					 */
    					String data = new String(byteArr, 0, readByteCount, "UTF-8");
    							
    					// 모든 클라이언트에게 보냄
    					/* 문자열을 모든 클라이언트에게 보내기 위해 connections에 저장된
    					 * Client를 하나씩 얻어 send() 메소드를 호출
    					 */
    					for(Client client : connections) {
    						client.send(data);
    					}
    				}
    			} catch(Exception e) {
    				try {
    					/* 예외가 발생하면 connections 컬렉션에서 Client 객체를 제거
    					 * 예외가 발생할 때는 모두 클라이언트와 통신이 되지 않을 때이다.
    					 */
    					connections.remove(Client.this);
    							
    					/* "[ 클라이언트 통신 안됨 : 클라이언트IP : 작업스레드이름 ]"으로
    					 * 구성된 문자열을 생성
    					 */
    					String message = "[ 클라이언트 통신 안됨 : " 
    									+  socket.getRemoteSocketAddress() 
    									+ ": " + Thread.currentThread().getName() 
    									+ " ]";
    					// 문자열을 출력하도록 displayText()를 호출
    					Platform.runLater(() -> displayText(message));
    					// Socket을 닫는다.
    					socket.close();
    				} catch(IOException e2) {}
    			}
    		}
    	};
    	// 스레드풀에서 처리
    	// 스레드풀에서 작업을 처리하기 위해 submit()을 호출
    	executorService.submit(runnable);
    }
    ```
    
- 클라이언트로 메시지를 보내는 `send(String data)` 메소드 코드
    
    ```java
    // 데이터를 보내기 위해 send() 메소들르 선언
    void send(String data) {
    	// 보내기 작업 생성
    	// 데이터를 클라이언트로 보내는 작업을 Runnable로 생성
    	Runnable runnable = new Runnable() {
    		// run()을 재정의
    		@Override
    		public void run() {
    			try {
    				// 클라이언트로 데이터 보내기
    				// 보낼 문자열로부터 UTF-8로 인코딩한 바이트 배열을 얻는다.
    				byte[] byteArr = data.getBytes("UTF-8");
    				// Socket에서 출력스트림을 얻는다.
    				OutputStream outputStream = socket.getOutputStream();
    				// 바이트 배열을 매개값으로 해서 write() 메소드를 호출
    				outputStream.write(byteArr);
    				// 출력 스트림의 내부 버퍼를 완전히 비우도록 flush()를 호출
    				outputStream.flush();
    			} catch(Exception e) {
    				try {
    					/* 예외가 발생하면 "[ 클라이언트 통신 안됨 : 클라이언트IP : 작업스레드이름 ]"으로
    					 * 구성된 문자열을 생성
    					 */
    					String message = "[ 클라이언트 통신 안됨 : " 
    							+ socket.getRemoteSocketAddress() + " : "
    							+ Thread.currentThread().getName() + " ]";
    					// 문자열을 출력하도록 displayText()를 호출
    					Platform.runLater(() -> displayText(message));
    							
    					// connections 컬렉션에서 예외가 발생한 Client를 제거
    					connections.remove(Client.this);
    					
    					// socket을 닫는다.
    					socket.close();
    				} catch(Exception e2) {}
    			}
    		}
    	};
    	// 스레드풀에서 처리
    	// 스레드풀에서 작업을 처리하기 위해 submit()을 호출
    	executorService.submit(runnable);
    }
    ```
    

## 5. UI 생성 코드

- JavaFX를 이용한 UI 생성 코드
    - 프로그램적 레이아웃을 이용해서 컴포넌트를 배치
    
    ```java
    TextArea txtDisplay;
    Button btnStartStop;
    	
    @Override
    public void start(Stage primaryStage) throws Exception {
    	BorderPane root = new BorderPane();
    	root.setPrefSize(500, 300);
    		
    	txtDisplay = new TextArea();
    	txtDisplay.setEditable(false);
    	BorderPane.setMargin(txtDisplay, new Insets(0, 0, 2, 0));
    	root.setCenter(txtDisplay);
    		
    	btnStartStop = new Button("start");
    	btnStartStop.setPrefHeight(30);
    	btnStartStop.setMaxWidth(Double.MAX_VALUE);
    		
    	/* start와 stop 버튼을 클랙했을 때
    	 * 이벤트 처리 코드
    	 */
    	btnStartStop.setOnAction(e -> {
    		if(btnStartStop.getText().equals("start")) {
    			startServer();
    		} else if(btnStartStop.getText().equals("stop")) {
    			stopServer();
    		}
    	});
    	root.setBottom(btnStartStop);
    		
    	Scene scene = new Scene(root);
    	scene.getStylesheets().add(getClass().getResource("app.css").toString());
    	primaryStage.setScene(scene);
    	primaryStage.setTitle("Server");
    		
    	/* 윈도우 우측 상단 닫기 버튼을 
    	 * 클릭했을 때 이벤트 처리 코드
    	 */
    	primaryStage.setOnCloseRequest(event -> stopServer());
    	primaryStage.show();
    }
    	
    /* 작업 스레드의 작업 처리 내용을 출력할 때 호출하는 메소드
     */
    void displayText(String text) {
    	txtDisplay.appendText(text + "\n");
    }
    	
    public static void main(String[] args) {
    	launch(args);
    }
    ```
    
- 외부 CSS 파일(app.css)을 Scene에 적용
    - TextArea의 배경색 때문
    - TextArea는 여러 겹의 컨테이너로 둘러싸여 있는 복잡한 구조를 가지고 있다.
        - 단순히 TextArea의 `setStyle()`로 배경색을 바꿀 수 없다.
    - 외부 CSS 클래스 선택자를 이용해서 컨테이너의 배경색을 변경
    - app.css
    
    ![Untitled](/images/lang_java/inputOutput/채팅_서버_구현/Untitled.png)
    
    ```css
    /* text-area 배경색 */
    .text-area {
    	-fx-background-color : gold;
    }
    
    /* scroll-pane 배경색 */
    .text-area .scroll-pane {
    	-fx-background-color : transparent;
    }
    
    /* viewport 배경색 */
    .text-area .scroll-pane .viewport{
    	-fx-background-color : transparent;
    }
    
    /* content 배경색 */
    .text-area .scroll-pane .content{
    	-fx-background-color : transparent;
    }
    ```
    
    - text-area만 gold색으로 설정
    - 나머지 컨테이너들은 모두 transparent로 설정함으로써 TextArea 전체 배경색이 gold로만 보이게 함
    
    ![2023-01-23 02 23 48.gif](/images/lang_java/inputOutput/채팅_서버_구현/2023-01-23_02_23_48.gif)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판