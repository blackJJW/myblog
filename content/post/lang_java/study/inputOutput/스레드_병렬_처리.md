---
title: "[Java] TCP 네트워킹, 스레드 병렬 처리"
description: ""
date: "2023-01-21T12:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "Network"
---
<!--more-->

- 연결 수락을 위해 ServerSocket의 `accept()`를 실행하거나, 서버 요청을 위해 Socket 생성자 또는 `connect()`를 실행한 경우
    - 해당 작업이 완료되기 전까지 블로킹(blocking)된다.
- 데이터 통신을 할 때에도 마찬가지
    - InputStream의 `read()` 메소드는 상대방이 데이터를 보내기 전까지 블로킹된다.
    - OutputStream의 `write()` 메소드는 데이터를 완전하게 보내기 전까지 블로킹된다.
    - ServerSocket과 Socket은 동기(블로킹) 방식으로 구동
- 만약 서버를 실행시키는 main 스레드가 직접 입출력 작업을 담당할 경우
    - 입출력이 완료될 때까지 다른 작업 불가한 상태가 된다.
    - 서버 애플리케이션은 지속적으로 클라이언트의 연결 수락 기능을 수행해야 한다.
        - 입출력에서 블로킹되면 이 작업을 할 수 없게 된다.
        - 클라이언트1과 입력하는 동안에는 클라이언트2와 입출력을 할 수 없게 된다.
    - `accept()`, `connect()`, `read()`, `write()`는 별도의 작업 스레드를 생성해서 병렬적으로 처리하는 것이 좋다.
    
    ### 서버가 별의 작업 스레드를 생성하고, 다중 클라이언트와 병렬적으로 통신하는 모습
    
    ![Untitled](/images/lang_java/inputOutput/스레드_병렬_처리/Untitled.png)
    
    - 위 그림과 가팅 스레드로 병렬 처리를 할 경우
        - 수천 개의 클라이언트가 동시에 연결되면 서버에서 수천 개의 스레드가 생성
            - 서버 기능이 급격히 저하
            - 다운되는 현상 발생 가능
    - 클라이언트의 폭증으로 인해 서버의 과도한 스레드 생성을 방지하려면 스레드풀을 사용하는 것이 바람직
    
    ### 스레드풀을 이용한 서버 구현 방식
    
    ![Untitled](/images/lang_java/inputOutput/스레드_병렬_처리/Untitled%201.png)
    
    - ①클라이언트가 연결 요청을 하면 ②서버의 스레드풀에서 연결 수락을 하고 Socket을 생성
    - ③클라이언트가 작업 처리 요청을 하면 ④서버의 스레드풀에서 요청을 처리하고 ⑤응답을 클라이언트로 보낸다.
- 스레드풀은 스레드 수를 제한해서 사용
    - 갑작스런 클라이언트의 폭증은 작업 큐의 작업량만 증가시킬 뿐 스레드 수는 변함이 없기 때문에 서버 성능은 완만히 저하
    - 다만 대기하는 작업량이 많을 경우 개별 클라이언트에서 응답을 늦게 받을 수 있다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판