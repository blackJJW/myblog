---
title: "[Java] 객체 입출력 보조 스트림"
description: ""
date: "2023-01-15T13:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
---
<!--more-->

- 자바는 메모리에 생성된 객체를 파일 또는 네트워크로 출력할 수 있다.
- 객체는 문자가 아니기 때문에 바이트 기반 스트림으로 출력해야 한다.
- 객체를 출력하기 위해서는 객체의 데이터(필드값)를 일렬로 늘어선 연속적인 바이트로 변경해야 한다.
    - 이것을 객체 직렬화(serialization)라고 한다.
- 반대로 파일에 저장되어 있거나 네트워크에서 전송된 객체를 읽을 수도 있다.
    - 입력 스트림으로부터 읽어들인 연속적인 바이트를 객체로 복원하는 것을 역직렬화(deserialization)라고 한다.

## 1. ObjectInputStream, ObjectOutputStream

- 자바는 객체를 입출력할 수 있는 두 개의 보조 스트림인 ObjectInputStream과 ObjectOutputStream을 제공
    - ObjectOutputStream은 바이트 출력 스트림과 연결되어 객체를 직렬화 하는 역할
    - ObjectInputStream은 바이트 입력 스트림과 연결되어 객체로 역직렬화하는 역할
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled.png)
    
- ObjectInputStream과 ObjectOutputStream은 다른 보조 스트림과 마찬가지로 연결할 바이트 입출력 스트림을 생성자의 매개값으로 받는다.
    
    ```java
    ObjectInputStream ois = new ObjectInputStream(바이트입력스트림);
    ObjectOutputStream oos = new ObjectOutputStream(바이트출력스트림);
    ```
    
    - ObjectOutputStream으로 객체를 직렬화하기 위해서는 `writeObject()` 메소드를 사용
    
    ```java
    oos.writeObject(객체);
    ```
    
    - 반대로 ObjectInputStream의 `readObject()` 메소드는 입력 스트림에서 읽은 바이트를 역직렬화해서 객체로 생성
        - `readObject()` 메소드의 리턴 타입은 Object 타입이기 때문에 객체 원래의 타입으로 변환해야 한다.
    
    ```java
    객체타입 변수 = (객체타입) ois.readObject();
    ```
    
- ex) 다양한 객체를 파일에 저장하고, 다시 파일로부터 읽어 객체로 복원하는 예제
    - 복수의 객체를 저장할 경우, 출력된 객체 순서와 동일한 순서로 읽어야 한다.
    - ObjectInputOutputStreamEx.java
    
    ```java
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    
    public class ObjectInputOutputStreamEx {
    
    	public static void main(String[] args) throws Exception {
    		FileOutputStream fos = new FileOutputStream("C:/Temp/Object.dat");
    		ObjectOutputStream oos = new ObjectOutputStream(fos);
    		
    		oos.writeObject(new Integer(10));
    		oos.writeObject(new Double(3.14));
    		oos.writeObject(new int[] { 1, 2, 3 });
    		oos.writeObject(new String("ABC"));
    		
    		oos.flush(); oos.close(); fos.close();
    		
    		FileInputStream fis = new FileInputStream("C:/Temp/Object.dat");
    		ObjectInputStream ois = new ObjectInputStream(fis);
    		
    		Integer obj1 = (Integer) ois.readObject();
    		Double obj2 = (Double) ois.readObject();
    		int[] obj3 = (int[]) ois.readObject();
    		String obj4 = (String) ois.readObject();
    		
    		ois.close(); fis.close();
    		
    		System.out.println(obj1);
    		System.out.println(obj2);
    		System.out.println(obj3[0] + ", " + obj3[1] + ", " + obj3[2]);
    		System.out.println(obj4);
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%201.png)
    

## 2. 직렬화가 가능한 클래스(Serializable)

- 자바는 Serializable 인터페이스를 구현한 클래스만 직렬화할 수 있도록 제한
- Serializable 인터페이스는 필드나 메소드가 없는 빈 인터페이스
    - 객체를 직렬화할 때 private 필드를 포함한 모든 필드를 바이트로 변환해도 좋다는 표시 역할을 수행
    
    ```java
    public class XXX implements Serializable { }
    ```
    
- 객체를 직렬화하면 바이트로 변환되는 것은 필드들
    - 생성자 및 메소드는 직렬화에 포함되지 않는다.
    - 따라서 역직렬화할 때에는 필드의 값만 복원된다.
    - 하지만 모든 필드가 직렬화 대상이 되는 것은 아니다.
        - 필드 선언에 static 또는 transient가 붙어 있을 경우에는 직렬화가 되지 않는다.
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%202.png)
    
- ex) 직렬화되는 필드와 그렇지 못한 필드가 어떤 것이 있는지 확인해주는 예제
    - 직렬화가 가능한 클래스
        - ClassA.java
    
    ```java
    import java.io.Serializable;
    
    public class ClassA implements Serializable {
    	int field1;                   // 직렬화에 포함
    	ClassB field2 = new ClassB(); // 직렬화에 포함
    	static int field3;            // 직렬화에 제외
    	transient int field4;         // 직렬화에 제외
    }
    ```
    
    - 직렬화가 가능한 클래스
        - ClassB.java
    
    ```java
    import java.io.Serializable;
    
    public class ClassB implements Serializable {
    	int field1; // 직렬화에 포함
    }
    ```
    
    - 직렬화해서 파일에 저장
        - SerializableWriter.java
    
    ```java
    import java.io.FileOutputStream;
    import java.io.ObjectOutputStream;
    
    public class SerializableWriter {
    
    	public static void main(String[] args) throws Exception {
    		FileOutputStream fos = new FileOutputStream("C:/Temp/Object.dat");
    		ObjectOutputStream oos = new ObjectOutputStream(fos);
    		
    		ClassA classA = new ClassA();
    		classA.field1 = 1;
    		classA.field2.field1 = 2;
    		classA.field3 = 3;
    		classA.field4 = 4;
    		oos.writeObject(classA);
    		oos.flush(); oos.close(); fos.close();
    	}
    }
    ```
    
    - 역직렬화해서 복원된 필드 조사
        - SerializableReader.java
    
    ```java
    import java.io.FileInputStream;
    import java.io.ObjectInputStream;
    
    public class SerializableReader {
    
    	public static void main(String[] args) throws Exception {
    		FileInputStream fis = new FileInputStream("C:/Temp/Object.dat");
    		ObjectInputStream ois = new ObjectInputStream(fis);
    		
    		ClassA v = (ClassA) ois.readObject();
    		System.out.println("field1 : " + v.field1);
    		System.out.println("field2.field1 : " + v.field2.field1);
    		System.out.println("field3 : " + v.field3);
    		System.out.println("field4 : " + v.field4);
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%203.png)
    
    1. SerializableWriter 클래스를 실행하면 ClassA 객체를 직렬화
        - Object.dat 파일에 저장
    2. SerializableReader 클래스를 실행하면 Object.dat 파일에 저장된 데이터를 읽고 ClassA 객체로 역직렬화
    - 실행 결과를 보면 field1과 field2는 값이 복원되는 것을 알 수 있다.
    - static 필드인 field3과 transient 필드인 field4는 값이 복원되지 않는다.
        - Object.dat 파일에는 field1과 field2의 데이터만 저장되어 있기 때문

## 3. serialVersionUID 필드

- 직렬화된 객체를 역직렬화할 때는 직렬화했을 때와 같은 클래스를 사용해야 한다.
- 클래스의 이름이 같더라도 클래스의 이름이 같더라도 클래스의 내용이 변경될 경우
    - 역직렬화는 실패하며 다음과 같은 예외가 발생
    
    ```java
    java.io.InvaildClassException: XXX; local class imcompatible: stream classdesc
    serialVersionUID = -9130799490637378756, local class serialVersionUID = -1174725809595957294
    ```
    
    - 위 예외의 내용은 직렬화할 때와 역직렬화할 때 사용된 클래스의 serialVersionUID가 다르다는 것
    - serialVersionUID는 같은 클래스임을 알려주는 식별자 역할을 수행
        - Serializable 인터페이스를 구현한 클래스를 컴파일하면 자동적으로 serialVersionUID 정적 필드가 추가
        - 클래스를 재컴파일할 경우 serialVersionUID의 값이 달라진다.
    - 네트워크로 객체를 직렬화하여 전송하는 경우
        - 보내는 쪽과 받는 쪽이 모두 같은 serialVersionUID를 갖는 클래스를 가지고 있어야 한다.
        - 한 쪽에서 클래스를 변경해서 재컴파일하면 다른 serialVersionUID를 가지게 되므로 역직렬화에 실패하게 된다.
- ex) 직렬화할 때 사용했던 클래스를 재컴파일한 후 역직렬화하면 예외가 발생한다는 것을 보여준다.
    - ClassC 클래스를 다음과 같이 작성
        - serialVersionUID 필드를 선언하지 않았기 때문에 컴파일 시 자동으로 생성
    - SerialVersionUIDEx1을 실행해서 객체를 파일에 저장한 후, SerialVersionUIDEx2를 실행하면 정상적으로 객체가 복원되는 것을 확인
    - 직렬화가 가능한 클래스
        - ClassC.java
    
    ```java
    import java.io.Serializable;
    
    public class ClassC implements Serializable {
    	int field1;
    }
    ```
    
    - 객체 직렬화
        - SerialVersionUIDEx1.java
    
    ```java
    import java.io.FileOutputStream;
    import java.io.ObjectOutputStream;
    
    public class SerialVersionUIDEx1 {
    
    	public static void main(String[] args) throws Exception {
    		FileOutputStream fos = new FileOutputStream("C:/Temp/Object.dat");
    		ObjectOutputStream oos = new ObjectOutputStream(fos);
    		ClassC classC = new ClassC();
    		classC.field1 = 1;
    		oos.writeObject(classC);
    		oos.flush(); oos.close(); fos.close();
    	}
    }
    ```
    
    - 객체 역직렬화
        - SerialVersionUIDEx2.java
    
    ```java
    import java.io.FileInputStream;
    import java.io.ObjectInputStream;
    
    public class SerialVersionUIDEx2 {
    
    	public static void main(String[] args) throws Exception {
    		FileInputStream fis = new FileInputStream("C:/Temp/Object.dat");
    		ObjectInputStream ois = new ObjectInputStream(fis);
    		
    		ClassC classC = (ClassC) ois.readObject();
    		System.out.println("field1 : " + classC.field1);
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%204.png)
    
- ex) ClassC 클래스에 field2 필드를 추가하고 컴파일을 한다.
    - field2가 추가되었기 때문에 serialVersionUID 필드값이 변경
    - 역직렬화할 클래스
        - ClassC.java
    
    ```java
    import java.io.Serializable;
    
    public class ClassC implements Serializable {
    	int field1;
    	int field2;
    }
    ```
    
    - 파일에 저장된 ClassC 객체를 복원하기 위해 SerialVersionUIDEx2를 실행하면 다음과 같은 예외가 발생
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%205.png)
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%206.png)
    
- 만약 불가피하게 클래스의 수정이 필요할 경우
    - 클래스 작성 시 serialVersionUID를 명시적으로 선언
    
    ```java
    public class XXX implements Serializable {
    	static final long serialVersionUID = 정수값;
    	...
    }
    ```
    
- 클래스에 SerialVersionUID가 명시적으로 선언되어 있을 경우
    - 컴파일 시에 serialVersionUID 필드가 추가되지 않기 때문에 동일한 serialVersionUID 값을 유지할 수 있다.
    - serialVersionUID의 값은 개발자가 임의로 줄 수 있지만 가능하다면 클래스마다 다른 값을 갖도록 하는 것이 좋다.
        - 자바는 <JDK 설치 경로>\bin 폴더에 serialVersionUID 값을 자동으로 생성시켜주는 serialver.exe 명령어를 제공
    
    ```bash
    serialver 클래스이름
    ```
    

## 4. writeObject()와 readObject() 메소드

- 두 클래스가 상속 관계에 있다고 가정
    - 부모 클래스가 Serializable 인터페이스를 구현하고 있을 경우
        - 자식 클래스는 Serializable 인터페이스를 구현하지 않아도 자식 객체를 직렬화하면 부모 필드 및 자식 필드가 모두 직렬화
    - 부모 클래스가 Serializable 인터페이슬 구현하고 있지 않고, 자식 클래스만 Serializable 인터페이스를 구현하고 있을 경우
        - 자식 객체를 직렬화할 때 부모의 필드는 직렬화에서 제외
        - 이 경우 부모 클래스의 필드를 직렬화하고 싶다면 다음 두 가지 방법 중 하나를 선택
            1. 부모 클래스가 Serializable 인터페이스를 구현
            2. 자식 클래스에서 `writeObject()`와 `readObject()` 메소드를 선언해서 부모 객체의 필드를 직접 출력
            - 첫 번째 방법이 제일 좋은 방법
            - 부모 클래스의 소스를 수정할 수 없는 경우에는 두 번째 방법을 사용해야 한다.
    - `writeObject()` 메소드는 직렬화할 때 자동으로 호출
    - `readObject()` 메소드는 역직렬화할 때 자동적으로 호출
- `writeObject()`와 `readObject()` 메소드의 선언 방법
    
    ```java
    private void writeObject(ObjectOutputStream out) throws IOException {
       out.writeXXX(부모필드); // 부모 객체의 필드값을 출력
       ...
       out.defaultWriteObject(); // 자식 객체의 필드값을 직렬화
    }
    ```
    
    ```java
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
       부모필드 = in.readXXX(); // 부모 객체의 필드값을 읽어옴
       ...
       in.defaultReadObject(); // 자식 객체의 필드값을 역직렬화
    }
    ```
    
    - 두 메소드를 작성할 때 주의할 점
        - 접근 제한자가 private가 아니면 자동 호출되지 않기 땜누에 반드시 private를 붙어주어야 한다.
    - `writeObject()`와 `readObject()` 메소드의 매개값인 ObjectOutputStream과 ObjectInputStream은 다양한 종류의 `writeXXX()`, `readXXX()` 메소드를 제공
        - 부모 필드 타입에 맞는 것을 선택해서 사용
    - `defaultWriteObject()`와 `defaultReadObject()`는 자식 클래스에 정의된 필드들을 모두 직렬화하고 역직렬화한다.
- ex)
    - Serializable을 구현하지 않은 부모 클래스
        - Parent.java
    
    ```java
    public class Parent {
    	public String field1;
    }
    ```
    
    - 직렬화되지 않는 부모 클래스의 필드 처리
        - Child.java
    
    ```java
    import java.io.IOException;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.io.Serializable;
    
    public class Child extends Parent implements Serializable {
    	public String field2;
    	
    	private void writeObject(ObjectOutputStream out) throws IOException {
    		out.writeUTF(field1);
    		out.defaultWriteObject();
    	}
    	
    	private void readObject(ObjectInputStream in) throws IOException,
    								ClassNotFoundException {
    		field1 = in.readUTF();
    		in.defaultReadObject();
    	}
    }
    ```
    
    - 직렬화 및 역직렬화
        - NonSerializableParentEx.java
    
    ```java
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    
    public class NonSerializableParentEx {
    
    	public static void main(String[] args) throws Exception {
    		FileOutputStream fos = new FileOutputStream("C:/Temp/Object.dat");
    		ObjectOutputStream oos = new ObjectOutputStream(fos);
    		Child child = new Child();
    		child.field1 = "ABC";
    		child.field2 = "DEF";
    		oos.writeObject(child);
    		oos.flush(); oos.close(); fos.close();
    		
    		FileInputStream fis = new FileInputStream("C:/Temp/Object.dat");
    		ObjectInputStream ois = new ObjectInputStream(fis);
    		Child v = (Child) ois.readObject();
    		System.out.println("field1 : " + v.field1);
    		System.out.println("field2 : " + v.field2);
    		ois.close(); fis.close();
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/inputOutput/객체_입출력_보조_스트림/Untitled%207.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판