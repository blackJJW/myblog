---
title: "[Java] UDP 네트워킹, 수신자 구현"
description: ""
date: "2023-01-23T12:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "Network"
---
<!--more-->

- 수신자로 사용할 DatagramSocket 객체는 바이딩할 포트 번호를 매개값으로 저장하고 생성
    
    ```java
    DatagramSocket datagramSocket = new DatagramSocket(5001);
    ```
    
    - DatagramSocket이 생성되었다면 `receive()` 메소드를 호출해서 패킷을 읽을 준비를 한다.
        - `receive()` 메소드는 패킷을 받을 때까지 블로킹된다.
        - 패킷이 도착하면 매개값으로 주어진 DatagramPacket에 패킷 내용을 저장
        
        ```java
        datagramSocket.receive(datagramPacket);
        ```
        
    - 패킷의 내용을 저장할 DatagramPacket 객체는 다음과 같이 생성
        - 첫 번째 매개값 : 읽은 패킷 데이터를 저장할 바이트 배열
        - 두 번째 매개값 : 읽을 수 있는 최대 바이트 수
            - 첫 번째 바이트 배열의 크기와 같거나 작아야 한다.
            - 일반적으로 첫 번째 바이트 배열의 크기를 준다.
        
        ```java
        DatagramPacket datagramPacket 
              = new DatagramPacket(new byte[100], 100);
        ```
        
- `receive()` 메소드로 패킷을 읽었다면 DatagramPacket의 `getData()` 메소드로 데이터가 저장된 바이트 배열을 얻어낼 수 있다.
    - `getLength()`를 호출해서 읽은 바이트 수를 얻을 수 있다.
    - 받은 데이터가 인코딩된 문자열이라면 디코딩해서 문자열을 얻으면 된다.
    
    ```java
    String data 
       = new String(packet.getData(), 0, 
                    packet.getLength(), "UTF-8");
    ```
    
- 만약 수신자가 패킷을 받고 나서 발신자에게 응답 패킷을 보내고 싶다면 발신자의 IP와 포트를 알아야 한다.
    - DatagramPacket의 `getSocketAddress()`를 호출하면 발신자의 SocketAddress 객체을 얻을 수 있다.
        - 발신자에게 응답 패킷을 보낼 때 `send()` 메소드에서 이용 가능
    
    ```java
    SocketAddress socketAddress = packet.getSocketAddress();
    ```
    
- 수신자는 항상 데이터를 받을 준비를 해야 하므로 작업 스레드를 생성해서 `receive()` 메소드를 반복적으로 호출해야 한다.
    - 작업 스레드를 종료시키는 방법
        - `receive()` 메소드가 블로킹되어 있는 상태에서 DatagramSocket의 `close()`를 호출
        - 이 경우 `receive()` 메소드에서 SocketException이 발생
            - 예외 처리 코드에서 작업 스레드를 종료시킨다.
    
    ```java
    datagramSocket.close();
    ```
    
- ex) 수신자 프로그렘의 전체 코드
    - 실행 후 10초가 지나면 수신자를 종료
    - UdpReceiveEx.java
    
    ```java
    import java.net.DatagramPacket;
    import java.net.DatagramSocket;
    
    public class UdpReceiveEx extends Thread {
    
    	public static void main(String[] args) throws Exception {
    		// 5001번 포트에서 수신하는 DatagramSocket 생성
    		DatagramSocket datagramSocket = new DatagramSocket(5001);
    		
    		Thread thread = new Thread() {
    			@Override
    			public void run() {
    				System.out.println("[ 수신 시작 ]");
    				try {
    					while(true) {
    						// DatagramPacket 수신
    						DatagramPacket packet 
    							= new DatagramPacket(new byte[100], 100);
    						datagramSocket.receive(packet);
    						
    						String data 
    							= new String(packet.getData(), 0, 
    									packet.getLength(), "UTF-8");
    						System.out.println("[ 받은 내용 : "
    								+ packet.getSocketAddress() + " ] "
    								+ data);
    					}
    				} catch(Exception e) {
    					System.out.println("[ 수신 종료 ]");
    				}
    			}
    		};
    		thread.start();
    		
    		Thread.sleep(10000);
    		datagramSocket.close();
    	}
    }
    ```
    
    - 수신자와 발신자를 모두 실행한 결과
    
    ![Untitled](/images/lang_java/inputOutput/수신자_구현/Untitled.png)
    
    - 실행 순서는 상관없지만, 수신자를 먼저 실행하고 발신자를 실행해야만 발신자가 보낸 데이터를 수신자가 모두 받을 수 있다.
    - 발신자를 먼저 실행하면 수신자가 실행하기 전에 보낸 데이터는 받을 수 없다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판