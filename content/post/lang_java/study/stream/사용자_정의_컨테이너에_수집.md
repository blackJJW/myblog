---
title: "[Java] 스트림, 사용자 정의 컨테이너에 수집"
description: ""
date: "2022-12-08T21:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 스트림은 요소들을 필터링, 또는 매핑해서 사용자 정의 컨테이너 객체에 수집할 수 있도록 다음과 같이 `collect()` 메소드를 추가적으로 제공
    
    
    | 인터페이스 | 리턴 타입 | 메소드(매개 변수) |
    | --- | --- | --- |
    | Stream | R | collect(Supplier<R>, BiConsumer<R, ?, super T>, BiConsumer<R, R>) |
    | IntStream | R | collect(Supplier<R>, ObjIntConsumer<R>, BiConsumer<R, R>) |
    | LongStream | R | collect(Supplier<R>, ObjLongConsumer<R>, BiConsumer<R, R>) |
    | DoubleStream | R | collect(Supplier<R>, ObjDoubleConsumer<R>, BiConsumer<R, R>) |
    - 첫 번째 `Supplier`는 요소들이 수집될 컨테이너 객체(R)를 생성하는 역할
        - 순차 처리(싱글 스레드) 스트림에서는 단 한 번 `Supplier`가 실행되고 하나의 컨테이너 객체를 생성
        - 병렬 처리(멀티 스레드) 스트림에서는 여러 번 `Supplier`가 실행되고 스레드별로 여러 개의 컨테이너 객체를 생성
            - 최종적으로 하나의 컨테이너 객체로 결합
    - 두 번째 `XXXConsumer`는 컨테이너 객체(R)에 요소(T)를 수집하는 역할
        - 스트림에서 요소를 컨테이너 수집할 때마다 `XXXConsumer`가 실행
    - 세 번째 `BiConsumer`는 컨테이너 객체(R)를 결합하는 역할
        - 순차 처리 스트림에서는 호출되지 않음
        - 병렬 처리 스트림에서만 호출되어 스레드별로 생성된 컨테이너 객체를 결합해서 최종 컨테이너 객체를 완성
    - 리턴 타입 R : 요소들이 최종 수집된 컨테이너 객체
        - 순차 처리 스트림에서는 리턴 객체가 첫 번째 `Supplier`가 생성한 객체
        - 병렬 처리 스트림에서는 최종 결합된 컨테이너 객체
- ex) 남학생이 저장되는 컨테이너
    - 순차 처리를 이용해서 사용자 정의 객체에 요소를 수집
    - 학생들 중에서 남학생만 수집하는 MaleStudent 컨테이너가 다음과 같이 정의
    - MaleStudent.java
    
    ```java
    import java.util.ArrayList;
    import java.util.List;
    
    public class MaleStudent {
    	private List<Student> list; // 요소를 저장할 컬렉션
    	
    	public MaleStudent() {
    		list = new ArrayList<Student>();
    		System.out.println("[ " + Thread.currentThread().getName() + " ] MaleStudent()");
    		                        // 생성자를 호출하는 스레드 이름
                                // 생성자가 몇 번 호출되었는지 확인
    	}
    	
    	public void accumulate(Student student) { // 요소를 수집하는 메소드
    		list.add(student);
    		System.out.println("[ " + Thread.currentThread().getName() + " ] accumulate()");
                                    // accumulate()를 호출하는 스레드 이름
                                    // accumulate()를 몇 번 호출되었는지 확인
    	}
    	
    	public void combine(MaleStudent other) { /* 두 MaleStudent를 결합하는 메소드
    	                                          * (병렬 처리 시에만 호출)
    	                                          * */
    		list.addAll(other.getList());
    		System.out.println("[ " + Thread.currentThread().getName() + " ] combine()");
                                   // combine()을 호출하는 스레드 이름
    	}
    	
    	public List<Student> getList(){ // 요소가 저장된 컬렉션을 리턴
    		return list;
    	}
    }
    ```
    
    - list 필드는 남학생들이 수집될 필드
    - 순차 처리 스트림에서 `MaleStudent()` 생성자는 딱 한 번 호출
        - 하나의 MaleStudent 객체만 생성
    - `accumulate()` 메소드 : 매개값으로 받은 Student를 list 필드에 수집
    - `combine()` 메소드 : 병렬 처리 스트림을 사용할 때 다른 MaleStudent와 결합할 목적으로 실행
        - 순차 처리 스트림에서는 호출되지 않기 때문에 정의할 필요가 없다고 생각되지만
            - `collect()` 메소드의 세 번째 매개값인 BiConsumer를 생성하기 위해 필요
- ex) 스트림에서 읽은 남학생을 MaleStudent에 수집하는 코드
    
    ```java
    1) Stream<Student> totalStream = totalList.stream();
    2) Stream<Student> maleStream = totalStream.filters(s->s.getSex()==Student.Sex.MALE);
    
    3) Supplier<MaleStudent> supplier = ()->new MaleStudent();
    4) BiConsumer<MaleStudent, Student> accumulator = (ms, s)->ms.accumulate(s);
    5) BiConsumer<MaleStudent, MaleStudent> combiner = (ms1, ms2)->ms1.combine(ms2);
    
    6) MaleStudent maleStudent = maleStream.collect(supplier, accumulator, combiner);
    ```
    
    1) 전체 학생 List에서 Stream을 얻는다.
    
    2) 남학생만 필터리해서 Stream을 얻는다.
    
    3) MaleStudent를 공급하는 Supplier를 얻는다.
    
    4) MaleStudent와 Student를 매개값으로 받아 MaleStudent의 `accumulate()` 메소드로 Student를 수집하는 BiConsumer를 얻는다.
    
    5) 두 개의 MaleStudent를 매개값으로 받아 `combine()` 메소드로 결합하는 BiConsumer를 얻는다.
    
    6) supplier가 제공하는 MaleStudent에 accumulator가 Student를 수집해서 최종 처리된 MaleStudent를 얻는다.
    
    - 싱글 스레드에서는 combiner는 사용되지 않는다.
    - 상기 코드에서 변수를 생략하면 다음과 같이 작성 가능
        
        ```java
        MaleStudent maleStudent = totalList.stream()
        	.filter(s -> s.getSex() == Student.Sex.MALE)
        	.collect()
        		() -> new MaleStudent(),
        		(r, t) -> r.accumulate(t),
        		(r1, r2) -> r1.combine(r2)
        );
        ```
        
    - 람다식을 메소드 참조로 변경하면 다음과 같이 더욱 간단하게 작성 가능
        
        ```java
        MaleStudent maleStudent = totalList.stream()
        	.filter(s -> s.getSex() == Student.Sex.MALE)
        	.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
        ```
        
- ex) 남학생을 MaleStudent에 누적
    - 순차 스트림을 이용해서 사용자 정의 컨테이너인 MaleStudent에 남학생만 수집
    - MaleStudentEx.java
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MaleStudentEx {
    
    	public static void main(String[] args) {
    		List<Student> totalList = Arrays.asList(
    				new Student("ABC", 10, Student.Sex.MALE),
    				new Student("DEF", 6, Student.Sex.FEMALE),
    				new Student("GHI", 10, Student.Sex.MALE),
    				new Student("JKL", 6, Student.Sex.FEMALE)
    		);
    		
    		MaleStudent maleStudent = totalList.stream()
    				.filter(s -> s.getSex() == Student.Sex.MALE)
    				.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
    		
    		maleStudent.getList().stream()
    			.forEach(s -> System.out.println(s.getName()));
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/stream/사용자_정의_컨테이너에_수집/Untitled.png)
  
  - 순차 처리를 담당한 스레드 : main
  - `MaleStudent()` 생성자가 딱 한 번 호출되었음
    - 한 개의 MaleStudent 객체가 생성
  - `accumulate()`가 두 번 호출
    - 요소들이 2번 수집됨
    - `collect()`가 리턴한 최종 MaleStudent에는 남학생 두명이 저장됨
    
- ex) 학생 클래스
    - Student.java
    
    ```java
    public class Student {
    	public enum Sex { MALE, FEMALE }
    	public enum City { Seoul, Pusan }
    	
    	private String name;
    	private int score;
    	private Sex sex;
    	private City city;
    	
    	public Student(String name, int score, Sex sex) {
    		this.name = name;
    		this.score = score;
    		this.sex = sex;
    	}
    	
    	public Student(String name, int score, Sex sex, City city) {
    		this.name = name;
    		this.score = score;
    		this.sex = sex;
    		this.city = city;
    	}
    	
    	public String getName() { return name; }
    	public int getScore() { return score; }
    	public Sex getSex() { return sex; }
    	public City getCity() { return city; }
    }
    ```
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판