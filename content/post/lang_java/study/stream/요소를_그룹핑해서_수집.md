---
title: "[Java] 스트림, 요소를 그룹핑해서 수집"
description: ""
date: "2022-12-10T12:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- `collect()` 메소드는 단순히 요소를 수집하는 기능 이외에 컬렉션의 요소들을 그룹핑해서 Map 객체를 생성하는 기능 제공
- `collect()`를 호출할 때 Collector의 `groupingBy()` 또는 `groupingByConcurrent()`가 리턴하는 Collector를 매개값으로 대입
    - `groupingBy()`는 스레드에 안전하지 않은 Map을 생성
    - `groupingByConcurrent()`는 스레드에 안전한 ConcurrentMap을 생성
    
    ![Untitled](/images/lang_java/stream/요소를_그룹핑해서_수집/Untitled.png)
    
- ex) 학생들을 성별로 그룹핑
    - 같은 그룹에 속하는 학생 List를 생성
    - 성별을 키로, 학생 List를 값으로 갖는 Map을 생성
    - `collect()`의 매개값으로 `groupingBy(Function<T, K> classifier)`를 사용
    
    ```java
    1) Stream<Student> totalStream = totalList.stream();
    
    2) Function<Student, Student.Sex> classifier = Student :: getSex;
    3) Collector<Student, ?, Map<Student.Sex, List<Student>> collector =
                                               Collectors.groupingBy(classifier);
    
    4) Map<Student.Sex, List<Student>> mapBySex = totalStream.collect(collector);
    ```
    
    1) 전체 학생 List에서 Stream을 얻는다.
    
    2) Student를 Student.Sex로 매핑하는 Function을 얻는다.
    
    3) Student.Sex가 키가 된다.
    
    - 그룹핑된 `List<Student>`가 값인 Map을 생성하는 Collector를 얻는다.
    
    4) Stream의 `collect()` 메소드로 Student를 Student.Sex 별로 그룹핑해서  Map을 얻는다.
    
    - 상기 코드에서 변수를 생략하면 다음과 같이 작성 가능
        
        ```java
        Map<Student.Sex, List<Student>> mapBySex = totalList.stream()
        		.collect(Collectors.groupingBy(Student :: getSex));
        ```
        
- ex) 학생들을 거주 도시별로 그룹핑
    - 같은 그룹에 속하는 학생들의 이름 List를 생성
    - 거주 도시를 키로, 이름 List를 값으로 갖는 Map을 생성
    - collect()의 매개값으로 `groupingBy(Function<T, K> classifier, Collector<T, A, D> collector)`를 사용
    
    ```java
    1) Stream<Student> totalStream = totalList.stream();
    
    2) Function<Student, Student.City> classifier = Student :: getCity;
    
    3) Function<Student, String> mapper = Student :: getName;
    4) Collector<String, ?, List<String>> collector1 = Collectors.toList();
    5) Collector<Student, ?, List<String>> collector2 = 
                                          Collectors.mapping(mapper, collector1);
    
    6) Collector<Student, ?, Map<Student.City, List<String>>> collector3 =
                                   Collectors.groupingBy(classifier, collector2);
    
    7) Map<Student.City, List<String>> mapByCity = totalStream.collect( collector3 );
    ```
    
    1) 전체 학생 List에서 Stream을 얻는다.
    
    2) Student를 `Student.City`로 매핑하는 Function을 얻는다.
    
    3 ~ 5) Student의 이름을 List에 수집하는 Collector를 얻는다.
    
    3) Student를 이름으로 매핑하는 Function을 얻는다.
    
    4) 이름을 List에 수집하는 Collector를 얻는다.
    
    5) Collectors의 `mapping()` 메소드로 Student를 이름으로 매핑하고 이름을 List에 수집하는 Collector를 얻는다.
    
    6) `Student.City`가 키, 그룹핑된 이름 List가 값인 Map을 생성하는 Collector를 얻는다.
    
    7) Stream의 `collect()` 메소드로 Student를 `Student.City`별로 그룹핑해서 Map을 얻는다.
    
    - 상기 코드에서 변수를 생략하면 다음과 같이 작성 가능
        
        ```java
        Map<Student.City, List<String>> mapByCity = totalList.stream()
        			.collect(
        				Collectors.groupingBy(
        					Student :: getCity,
        					Collectors.mapping(Student :: getName, Collectors.toList())
        				)
        );
        ```
        
    - 다음 코드는 위와 동일
        - TreeMap 객체를 생성하도록 `groupingBy(Function<T, K> classifier, Supplier<Map<K, D>> mapFactory, Collector<T, A, D> collector)` 를 사용
        
        ```java
        Map<Student.City, List<String>> mapByCity = totalList.stream()
        			.collect(
        				Collectors.groupingBy(
        					Student :: getCity,
        					TreeMap :: new,
        					Collectors.mapping(Student :: getName, Collectors.toList())
        				)
        );
        ```
        
- ex) 성별로 그룹핑
    - GroupingByEx.java
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Collectors;
    
    public class GroupingByEx {
    
    	public static void main(String[] args) {
    		List<Student> totalList = Arrays.asList(
    				new Student("ABC", 10, Student.Sex.MALE, Student.City.Seoul),
    				new Student("DEF", 6, Student.Sex.FEMALE, Student.City.Pusan),
    				new Student("GHI", 10, Student.Sex.MALE, Student.City.Pusan),
    				new Student("JKL", 6, Student.Sex.FEMALE, Student.City.Seoul)
    		);
    		
    		Map<Student.Sex, List<Student>> mayBySex = totalList.stream()
    				.collect(Collectors.groupingBy(Student :: getSex));
    		
    		System.out.print("[ 남학생 ]");
    		mayBySex.get(Student.Sex.MALE).stream()
    			.forEach(s -> System.out.print(s.getName() + " "));
    		
    		System.out.print("\n[ 여학생 ]");
    		mayBySex.get(Student.Sex.FEMALE).stream()
    			.forEach(s -> System.out.print(s.getName() + " "));
    		
    		System.out.println();
    		
    		Map<Student.City, List<String>> mapByCity = totalList.stream()
    				.collect(
    					Collectors.groupingBy(
    						Student :: getCity,
    						Collectors.mapping(Student :: getName, Collectors.toList())
    					)
    				);
    		
    		System.out.print("\n[ 서울 ]");
    		mapByCity.get(Student.City.Seoul).stream()
    			.forEach(s -> System.out.print(s + " "));
    		
    		System.out.print("\n[ 부산 ]");
    		mapByCity.get(Student.City.Pusan).stream()
    			.forEach(s -> System.out.print(s + " "));
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/stream/요소를_그룹핑해서_수집/Untitled%201.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판