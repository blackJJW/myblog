---
title: "[Java] 병렬 처리, 병렬 스트림 생성"
description: ""
date: "2022-12-11T15:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 병렬 처리를 위해 코드에서 포크조인 프레임워크를 직접 사용할 수 있지만, 병렬 스트림을 이용할 경우에는 백그라운드에서 포크조인 프레임워크가 사용되기 때문에 쉽게 병렬 처리를 할 수 있다.
    
    ### 병렬 스트림은 다음 두 가지 메소드로 얻을 수 있다.
    
    ![Untitled](/images/lang_java/parallel_operation/병렬_스트림_생성/Untitled.png)
    
    - `parallelStream()` 메소드는 컬렉션으로부터 병렬 스트림을 바로 리턴
    - `parallel()` 메소드는 순차 처리 스트림을 병렬 처리 스트림으로 변환해서 리턴
    - 어떤 방법으로 병렬 스트림을 얻더라도 이후 요소 처리 과정은 병렬 처리된다.
    - 내부적으로 전체 요소를 서브 요소들로 나눈다.
        - 이 서브 요소들을 개별 스레드가 처리
        - 서브 처리 결과가 나오면 결합해서 마지막으로 최종 처리 결과를 리턴
- ex) 내부적인 동작 확인
    - 사용자 정의 컨테이너에 수집하기 예제(수정 전)
        
        ```java
        MaleStudent maleStudent = totalList.stream()
        	.filter(s -> s.getSex() == Student.Sex.MALE)
        	.collect(MaleStudent :: new, MaleStudent :: accumulate, 
        			MaleStudent :: combine);
        ```
        
        - 전체 학생 목록에서 `stream()` 메소드로 순차 처리 스트림을 얻었기 때문에 MaleStudent 객체는 하나만 생성
        - 남학생을 MaleStudent에 수집하기 위해 `accumulate()`가 호출된다.
        - `combine()` 메소드는 전혀 호출되지 않는다.
            - 이유는 순차 처리 스트림이므로 결합할 서브 작업이 없기 때문
    - 위 코드를 병렬 처리 스트림으로 변경
        
        ```java
        MaleStudent maleStudent = totalList.parallelStream()
        	.filter(s -> s.getSex() == Student.Sex.MALE)
        	.collect(MaleStudent :: new, MaleStudent :: accumulate,
        			MaleStudent :: combine);
        ```
        
        - 단순히 `stream()` 메소드 호출이 `parallelStream()` 메소드 호출로 변경
        - 내부 동작은 다음과 같은 순서로 전혀 다르게 진행
            1. 쿼드 코어 CPU에서 실행된다면 전체 요소는 4개의 서브 요소로 나눠진다.
                1. 4개의 스레드가 병렬 처리
                2. 각 스레드는 서브 요소를 수집해야 하므로 4개의 MaleStudent 객체를 생성하기 위해 `collect()`의 첫 번째 메소드 참조인 `MaleStudent :: new` 를 4번 실행
            2. 각 스레드는 MaleStudent 객체에 남학생 요소를 수집하기 위해 두 번째 메소드 참조인 `MaleStudent :: accumulate`를 매번 실행
            3. 수집이 완료된 4개의 MaleStudent는 3번의 결합으로 최종 MaleStudent가 만들어질 수 있으므로 세 번째 메소드 참조인 `MaleStudent :: combine`이 3번 실행
- ex) 남학생을 MaleStudent에 누적
    - Student.java
        
        ```java
        public class Student {
        	public enum Sex { MALE, FEMALE }
        	public enum City { Seoul, Pusan }
        	
        	private String name;
        	private int score;
        	private Sex sex;
        	private City city;
        	
        	public Student(String name, int score, Sex sex) {
        		this.name = name;
        		this.score = score;
        		this.sex = sex;
        	}
        	
        	public Student(String name, int score, Sex sex, City city) {
        		this.name = name;
        		this.score = score;
        		this.sex = sex;
        		this.city = city;
        	}
        	
        	public String getName() { return name; }
        	public int getScore() { return score; }
        	public Sex getSex() { return sex; }
        	public City getCity() { return city; }
        }
        ```
        
    - MaleStudent.java
        
        ```java
        import java.util.ArrayList;
        import java.util.List;
        
        public class MaleStudent {
        	private List<Student> list; // 요소를 저장할 컬렉션
        	
        	public MaleStudent() {
        		list = new ArrayList<Student>();
        		System.out.println("[ " + Thread.currentThread().getName() + " ] MaleStudent()");
        		                        // 생성자를 호출하는 스레드 이름
        	}
        	
        	public void accumulate(Student student) { // 요소를 수집하는 메소드
        		list.add(student);
        		System.out.println("[ " + Thread.currentThread().getName() + " ] accumulate()");
                                        // accumulate()를 호출하는 스레드 이름
        	}
        	
        	public void combine(MaleStudent other) { /* 두 MaleStudent를 결합하는 메소드
        	                                          * (병렬 처리 시에만 호출)
        	                                          * */
        		list.addAll(other.getList());
        		System.out.println("[ " + Thread.currentThread().getName() + " ] combine()");
                                       // combine()을 호출하는 스레드 이름
        	}
        	
        	public List<Student> getList(){ // 요소가 저장된 컬렉션을 리턴
        		return list;
        	}
        }
        ```
        
    - MaleStudentEx.java
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class MaleStudentEx {
    
    	public static void main(String[] args) {
    		List<Student> totalList = Arrays.asList(
    			new Student("ABC", 10, Student.Sex.MALE),
    			new Student("DEF", 10, Student.Sex.FEMALE),
    			new Student("GHI", 10, Student.Sex.MALE),
    			new Student("JKL", 10, Student.Sex.FEMALE)
    		);
    		
    		MaleStudent maleStudent = totalList.parallelStream()
    				.filter(s -> s.getSex() == Student.Sex.MALE)
    				.collect(MaleStudent :: new, MaleStudent :: accumulate, 
    						MaleStudent :: combine);
    		
    		maleStudent.getList().stream()
    			.forEach(s -> System.out.println(s.getName()));
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/parallel_operation/병렬_스트림_생성/Untitled%201.png)
    
    - 실행 결과를 보면 main 스레드와 ForkJoinPool에서 3개의 스레드가 사용되어 총 4개의 스레드가 동작
        - 사용하는 컴퓨터가 쿼드 코어 CPU를 사용하기 때문
    - 각각의 스레드가 하나의 서브 작업이라고 본다면 총 4개의 서브 작업으로 분리되었다고 생각하면 된다.
    - 각 서브 작업은 남학생을 누적시킬 MaleStudent 객체를 별도로 생성하기 때문에 `MaleStudent()` 생성자가 4번 실행
    - 전체 학생 중에서 남학생이 2명밖에 없으므로 `accumulate()`는 2번밖에 호출되지 않음
    - 누적이 완료된 4개의 MaleStudent 객체는 3번의 결합으로 최종 MaleStudent가 만들어지므로 `combine()` 메소드가 3번 호출
    
    ![Untitled](/images/lang_java/parallel_operation/병렬_스트림_생성/Untitled%202.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판