---
title: "[Java] 병렬 처리, 병렬 처리 성능"
description: ""
date: "2022-12-11T16:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 스트림 병렬 처리가 스트림 순차 처리보다 항상 실행 성능이 좋다고 판단해서는 안 된다.

## 병렬 처리에 영향을 미치는 3가지 요인

### 1. 요소의 수와 요소당 처리 시간

- 컬렉션에 요소의 수가 적고 요소당 처리 시간이 짧으면 순차 처리가 오히려 병렬 처리보다 빠를 수 있다.
- 병렬 처리는 스레드풀 생성, 스레드 생성이라는 추가적인 비용이 발생하기 때문

### 2. 스트림 소드의 종류

- ArrayList, 배열은 인덱스로 요소를 관리하기 때문에 포크 단계에서 요소를 쉽게 분리할 수 있어 병렬 처리 시간이 절약
    - HashSet, TreeSet은 요소 분리가 쉽지 않다.
    - LinkedList은 링크를 따라가야 하므로 요소 분리가 쉽지 않다.
    - 이 소스들은 ArrayList, 배열보다는 상대적으로 병렬 처리가 늦다.

### 3. 코어(Core)의 수

- 싱글 코어 CPU일 경우에는 순차 처리가 빠르다.
- 병렬 스트림을 사용할 경우 스레드의 수만 증가하고 동시성 작업으로 처리되기 때문에 좋지 못한 결과를 보여 준다.
- 코어의 수가 많으면 많을수록 병렬 작업 처리 속도는 빨라진다.

---

- ex) 순차 처리와 병렬 처리 성능 비교
    - `work()` 메소드의 실행 시간(요소당 처리 시간)을 조정함으로써 순차 처리와 병렬 처리 중 어떤 것이 전체 요소를 빨리 처리하는지 테스트
    - SequencialVsParallelEx.java
    
    ```java
    import java.util.Arrays;
    import java.util.List;
    
    public class SequencialVsParallelEx {
    	// 요소 처리
    	public static void work(int value) {
    		try { Thread.sleep( 100 ); } catch (InterruptedException e) {}
    	}
    	
    	// 순차 처리
    	public static long testSequencial(List<Integer> list) {
    		long start = System.nanoTime();
    		list.stream().forEach((a) -> work(a));
    		long end = System.nanoTime();
    		long runTime = end - start;
    		return runTime;
    	}
    	
    	// 병렬 처리
    	public static long testParallel(List<Integer> list) {
    		long start = System.nanoTime();
    		list.stream().parallel().forEach((a) -> work(a));
    		long end = System.nanoTime();
    		long runTime = end - start;
    		return runTime;
    	}
    	
    	public static void main(String[] args) {
    		// 소스 컬렉션
    		List<Integer> list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    		
    		// 순차 스트림 처리 시간 구하기
    		long timeSequencial = testSequencial(list);
    		
    		// 병렬 스트림 처리 시간 구하기
    		long timeParallel = testParallel(list);
    		
    		if(timeSequencial < timeParallel) {
    			System.out.println("성능 테스트 결과 : 순차 처리가 더 빠름");
    		} else {
    			System.out.println("성능 테이스 결과 : 병렬 처리가 더 빠름");
    		}
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/parallel_operation/병렬_처리_성능/Untitled.png)
    
    - 실행 결과는 `work()`의 요소 처리 시간에 따라 달라진다.
- ex) 스트림 소드와 병렬 처리 성능
    - 스트림 소스가 ArrayList인 경우와 LinkedList일 경우 대용량 데이터의 병렬 처리 성능을 테스트
    - 백만 개의 Integer 객체를 각각 ArrayList와 LinkedList에 저장하고 테스트
    - ArrayListVsLinkedListEx.java
    
    ```java
    import java.util.ArrayList;
    import java.util.LinkedList;
    import java.util.List;
    
    public class ArrayListVsLinkedListEx {
    	
    	// 요소 처리
    	public static void work(int value) {
    	}
    	
    	// 병렬 처리
    	public static long testParallel(List<Integer> list) {
    		long start = System.nanoTime();
    		list.stream().parallel().forEach((a) -> work(a));
    		long end = System.nanoTime();
    		long runTime = end - start;
    		return runTime;
    	}
    	
    	public static void main(String[] args) {
    		// 소스 컬렉션
    		List<Integer> arrayList = new ArrayList<Integer>();
    		List<Integer> linkedList = new LinkedList<Integer>();
    		for(int i = 0; i < 1000000; i++) {
    			arrayList.add(i);
    			linkedList.add(i);
    		}
    		
    		// 워밍업
    		long arrayListListParallel = testParallel(arrayList);
    		long linkedListParallel = testParallel(linkedList);
    		
    		// 병렬 스트림 처리 시간 구하기
    		arrayListListParallel = testParallel(arrayList);
    		linkedListParallel = testParallel(linkedList);
    		
    		if(arrayListListParallel < linkedListParallel) {
    			System.out.println("성능 테스트 결과 : ArrayList 처리가 더 빠름");
    		} else {
    			System.out.println("성는 테스트 결과 : LinkedList 처리가 더 빠름");
    		}
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/parallel_operation/병렬_처리_성능/Untitled%201.png)
    
    - 실행 결과는 ArrayList가 빠른 실행 성능을 보였다.
    - 요소의 개수가 적을 경우에는 LinkedList가 더 빠른 성능을 보였다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판