---
title: "[Java] 스레드풀, 작업 완료 순으로 통보"
description: ""
date: "2022-10-25T23:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 작업 요청 순서대로 작업 처리가 완료되는 것은 아니다.
- 작업의 양과 스레드 스케줄링에 따라서 먼저 요청한 작업이 나중에 완료되는 경우도 발생
- 여러 개의 작업들이 순자척으로 처리될 필요성 없을 경우
    - 처리 결과도 순차적으로 이용할 필요가 없다면 작업 처리가 완료된 것부터 결과를 얻어 이용하면 된다.
- 스레드풀에서 작업 처리가 완료된 것만 통보받는 방법
    - `CompletionService`를 이용
    - `CompletionService`는 처리 완료된 작업을 가져오는 `poll()`과 `take()` 메소드를 제공
    
    | 리턴 타입 | 메소드명(매개 변수) | 설명 |
    | --- | --- | --- |
    | Future<V> | poll() | 완료된 작업의 Future를 가져옴. 완료된 작업이 없다면 즉시 null 리턴 |
    | Future<V> | poll(long timeout, TimeUnit unit) | 완료된 작업의 Future를 가져옴. 완료된 작업이 없다면 timeout까지 블로킹됨. |
    | Future<V> | take() | 완료된 작업의 Future를 가져옴. 완료된 작업이 없다면 있을 때까지 블로킹됨. |
    | Future<V> | submit(Callable<V> task) | 스레드풀에 Callable 작업 처리 요청 |
    | Future<V> | submit(Runnable task, V result) | 스레드풀에 Runnable 작업 처리 요청 |
- `CompletionService` 구현 클래스는 `ExecutorCompletionService<V>`
    - 객체를 생성할 때 생성자 매개값으로 `ExecutorService`를 제공
    
    ```java
    ExecutorService executorService = Executors.newFixedThreadPool(
    	Runtime.getRuntime().availableProcessors()
    );
    //------------------------------------------------------------------------
    CompletionService<V> completionService = new ExecutorCompletionService<V>(
    	executorService
    );
    //------------------------------------------------------------------------
    ```
    
- poll()과 take() 메소드를 이용해서 처리 완료된 작업의 Future를 얻으려면 `CompletionService`의 `submit()` 메소드로 작업 처리 요청을 해야 한다.
    
    ```java
    completionService.submit(Callable<V> task);
    completionService.submit(Runnable task, V result);
    ```
    
- `take()` 메소드를 호출하여 완료된 Callable 작업이 있을 때까지 블로킹되었다가 완료된 작업의 Future를 얻고, `get()` 메소드로 결과값을 얻어내는 코드
    - while문은 애플리케이션이 종료될 때까지 반복 실행해야 하므로 스레드풀의 스레드에서 실행하는 것이 좋다.
    
    ```java
    // 스레드풀의 스레드에서 실행하도록 함
    executorService.submit(new Runnable() {
    	@Override
    	public void run(){
    		while(true){
    			try{
    				Future<Integer> future = completionService.take();
    				                      /* 완료된 작업이 있을 때까지 블로킹,
                                  */ 완료된 작업이 있으면 Future를 리턴
    				int value = future.get();
    	                        // get()은 블로킹되지 않고 바로 작업 결과 리턴
            System.out.println("[ 처리 결과 ] " + value);
    			} catch (Exception e) {
    				break;
    			}
    		}
    	}
    });
    ```
    
    - `take()` 메소드가 리턴하는 완료된 작업은 `submit()`으로 처리 요청한 작업의 순서가 아님을 명심
        - 작업의 내용에 따라서 먼저 요청한 작업이 나중에 완료될 수도 있기 때문
    - 더 이상 완료된 작업을 가져올 필요가 없다면 `take()` 블로킹에서 빠져나와 while문을 종료해야 한다.
    - `ExecutorService`의 `shutdownNow()`를 호출하면 `take()`에서 `InterruptedException`이 발생하고 catch 절에서 break가 되어 while문을 종료
- ex) 작업 완료 순으로 통보 받기
    - 3개의 Callable 작업을 처리 요청하고 처리가 완료되는 순으로 작업의 결과값을 콘솔에 출력
    - CompletionServiceEx.java
    
    ```java
    import java.util.concurrent.Callable;
    import java.util.concurrent.CompletionService;
    import java.util.concurrent.ExecutorCompletionService;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.Future;
    
    public class CompletionServiceEx {
    
    	public static void main(String[] args) {
    		ExecutorService executorService = Executors.newFixedThreadPool(
    				Runtime.getRuntime().availableProcessors()				
    				);
    		
    		// CompletionService 생성
    		CompletionService<Integer> completionService = 
    				new ExecutorCompletionService<Integer>(executorService);
    		
    		System.out.println("[ 작업 처리 요청 ]");
    		for(int i = 0; i < 3; i++) {
    			completionService.submit(new Callable<Integer>(){
    				@Override
    				public Integer call() throws Exception{
    					int sum = 0;
    					for(int i = 1; i <= 10; i++) {
    						sum += i;
    					}
    					return sum;
    				}
    			});
    		}
    		
    		System.out.println("[ 처리 완료된 작업 확인 ]");
    		
    		// 스레드풀의 스레드에서 실행
    		executorService.submit(new Runnable() {
    			@Override
    			public void run() {
    				while(true) {
    					try {
    						Future<Integer> future = completionService.take();
    						                        // 완료된 작업 가져오기
    						
    						int value = future.get();
    						System.out.println("[ 처리 결과 ] " + value);
    					} catch (Exception e) {
    						break;
    					}
    				}
    			}
    		});
    		
    		try { Thread.sleep(3000); }
    		catch (InterruptedException e) {}
    		executorService.shutdownNow();
    	}
    
    }
    ```
    
    ![Untitled](/images/lang_java/multi_thread/스레드풀,_작업_완료_순으로_통보/Untitled.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판