---
title: "[Java] 동기화 메소드 및 동기화 블록"
description: ""
date: "2022-10-06T20:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야 한다.
- 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역(critical section)이라고 한다.
- 자바는 임계 영역을 지정하기 위해 동기화(synchronized) 메소드와 동기화 블록을 제공
- 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 한다.
- 동기화 메소드를 만드는 방법은 메소드 선언에 `synchronized` 키워드를 붙인다.
    - `synchronized` 키워드는 인스턴스와 정적 메소드 어디든 붙일 수 있다.
    
    ```java
    public synchronized void method() {
    	임계 영역; // 단 하나의 스레드만 실행
    }
    ```
    
- 동기화 메소드는 메소드 전체 내용이 임계 영역이므로 스레드가 동기화 메소드를 실행하는 즉시 객체에서 잠금이 발생
    - 스레드가 동기화 메소드를 실행 종료하면 잠금이 풀린다.
- 메소드 전체 내용이 아니라, 일부 내용만 임계 영역으로 만들고 싶다면 다음과 같이 동기화(synchronized) 블록을 만들면 된다.
    
    ```java
    public void method() {
    	// 여러 스레드가 싫행 가능 영역
    	...
    
    	/* 공유 객체가 객체 자신이면
    	 * this를 넣을 수 있다.
    	*/
    	// 동기화 블록
    	synchronized(공유객체)	{
    		임계 영역 // 단 하나의 스레드만 싫행
    	}
    	// 여러 스레드가 실행 가능 영역
    	...
    }
    ```
    
- 동기화 블록의 외부 코드들은 여러 스레드가 동시에 실행 가능
    - 동기화 블록 내부 코드는 임계 영역이므로 한 번에 한 스레드만 실행 가능
    - 다른 스레드는 실행 불가능
- 만약 동기화 메소드와 동기화 블록이 여러개 있을 경우
    - 스레드가 이들 중 하나를 실행할 때 다른 스레드는 해당 메소드는 물론이고 다른 동기화 메소드 및 블록도 실행 불가능
    - but, 일반 메소드는 실행이 가능
    
    ![Untitled](/images/lang_java/multi_thread/동기화_메소드_및_동기화_블록/Untitled.png)
    
- ex) 동기화 메소드로 수정된 공유 객체
    - Calculator의 `setMemory()` 메소드를 동기화 메소드로 만들어서 User1 스레드가 `setMemory()`를 실행할 동안 User2 스레드가 `setMemory()` 메소드를 실행할 수 없도록 한다.
    - Calculator.java
    
    ```java
    public class Calculator {
    	private int memory;
    	
    	public int getMemory() {
    		return memory;
    	}
    	
    	public synchronized void setMemory(int memory) {
    		this.memory = memory; 
    		try {
    			Thread.sleep(2000);
    		} catch(InterruptedException e) {}
    		System.out.println(Thread.currentThread().getName() + " : " + this.memory);
    	}
    
    }
    ```
    
    - User1.java
    
    ```java
    public class User1 extends Thread{
    	private Calculator calculator;
    	
    	public void setCalculator(Calculator calculator) {
    		// 스레드 이름을 User1로 설정
    		this.setName("User1");
    		// 공유 객체인 Caculator를 필드에 저장
    		this.calculator = calculator;
    	}
    	
    	public void run() {
    		// 공유 객체인 Calculator의 메모리에 100d을 저장
    		calculator.setMemory(100);
    	}
    
    }
    ```
    
    - User2.java
    
    ```java
    public class User2 extends Thread{
    	private Calculator calculator;
    	
    	public void setCalculator(Calculator calculator) {
    		// 스레드 이름을 User2로 설정
    		this.setName("User2");
    		// 공유 객체인 Caculator를 필드에 저장
    		this.calculator = calculator;
    	}
    	
    	public void run() {
    		// 공유 객체인 Calculator의 메모리에 50을 저장
    		calculator.setMemory(50);
    	}
    
    }
    ```
    
    - MainThreadEx.java
    
    ```java
    public class MainThreadEx {
    
    	public static void main(String[] args) {
    		Calculator calculator = new Calculator();
    		
    		// User1 스레드 생성
    		User1 user1 = new User1();
    		// 공유 객체 설정
    		user1.setCalculator(calculator);
    		// User1 스레드 시작
    		user1.start();
    		
    		// User2 스레드 생성
    		User2 user2 = new User2();
    		// 공유 객체 설정
    		user2.setCalculator(calculator);
    		// User1 스레드 시작
    		user2.start();
    
    	}
    
    }
    ```
    
    ![Untitled](/images/lang_java/multi_thread/동기화_메소드_및_동기화_블록/Untitled%201.png)
    
    ![Untitled](/images/lang_java/multi_thread/동기화_메소드_및_동기화_블록/Untitled%202.png)
    
    - User1 스레드는 Caculator 객체의 동기화 메소드인 `setMemory()`를 실행하는 순간 Calculator 객체를 잠근다.
    - 메인 스레드가 User2 스레드를 실행시키지만
        - 동기화 메소드인 `setMemory()`를 실행시키지 못함
        - User1이 `setMemory()`를 모두 실행할 동안 대기해야함
    - User1 스레드가 `setMemory()`를 실행하고 난 후
        - User2 스레드가 setMemory() 메소드를 실행
    - 결국 User1 스레드가 Calculator 객체를 사용할 동안
        - User2 스레드는 Calculator 객체를 사용하지 못하므로 User1 스레드는 안전하게 방해받지 않고 Calculator 객체를 사용할 수 있게 된다.
- ex) 위 예제를 동기화 블록으로 수정
    
    ```java
    public void setMemory(int memory){
    	synchronized (this) {
    	            // 공유 객체인 Calculator 참조(잠금 대상)
    
    		this.memory = memory;
    		try {
    			Thread.sleep(2000);
    		} catch(InterruptedException e) {}
    		System.out.println(Thread.currentThread().getName() + " : " + this.memory);
    	}
    }
    ```
    
    - 스레드가 동기화 블록으로 들어가면 `this`(Calculator 객체)를 잠그고, 동기화 블록을 실행
    - 동기화 블록을 모두 실행할 때까지 다른 스레드들은 `this`(Calculator 객체)의 모든 동기화 메소드 또는 동기화 블록을 실행할 수 없다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판