---
title: "[Java] 스레드풀, 작업 생성과 처리 요청"
description: ""
date: "2022-10-16T12:40:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

## 작업 요청

- 하나의 작업은 Runnable 또는 Callable 구현 클래스로 표현
- Runnable과 Callable의 차이점은 작업 처리 완료 후 리턴값이 있느냐 없느냐이다.
- 다음은 작업을 정의하기 위해 Runnable과 Callable 구현 클래스를 작성하는 방법
    
    ![Untitled](/images/lang_java/multi_thread/스레드풀,_작업_생성과_처리_요청/Untitled.png)
    
    - Runnable의 `run()`메소드는 리턴값이 없다.
    - Callable의 `run()` 메소드는 리턴값이 있다.
    - `call()`의 리턴 타입은 `implements Callable<T>`에서 지정한 T 타입
    - 스레드풀의 스레드는 작업 큐에서 Runnable 또는 Callable 객체를 가져와 `run()`과 `call()` 메소드를 실행

## 작업 처리 요청

- 작업 처리 요청 : ExecutorService의 작업 큐에 Runnable 또는 Callable 객체를 넣는 행위
- ExecutorService는 작업 처리 요청을 위해 다음 두 가지의 종류의 메소드를 제공
    
    ![Untitled](/images/lang_java/multi_thread/스레드풀,_작업_생성과_처리_요청/Untitled%201.png)
    
    - `execute()`와 `submit()` 메소드의 차이점은 두 가지
        1. `execute()`는 작업 처리 결과를 받지 못하고, `submit()`은 작업 처리 결과를 받을 수 있도록 Future를 리턴
        2. execute()는 작업 처리 도중 예외가 발생하면 스레드가 종료되고 해당 스레드는 스레드풀에서 제거
            - 따라서 스레드풀은 다른 작업 처리를 위해 새로운 스레드를 생성
            - 반면에 `submit()`은 작업 처리 도중 예외가 발생하더라도 스레드는 종료되지 않고 다음 작업을 위해 재사용된다.
        - 가급적 스레드의 생성 오버헤더를 줄이기 위해 `submit()`을 사용하는 것이 좋다.
- ex) `execute()`, `submit()` 메소드로 작업 처리 요청한 경우
    - Runnable 작업을 정의할 때 `Integer.parseInt(”삼”)`을 넣어 NumberFormatException이 발생하도록 유도
    - 10개 작업을 `execute()`와 `submit()` 메소드로 각각 처리 요청했을 경우 스레드풀의 상태가 목적
    - ExecuteEx.java
    
    ```java
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.ThreadPoolExecutor;
    
    public class ExecuteEx {
    
    	public static void main(String[] args) throws Exception {
    		// 최대 스레드 개수가 2인 스레드풀 생성
    		ExecutorService executorService = Executors.newFixedThreadPool(2);
    		
    		for(int i = 0; i < 10; i++) {
    			// 작업 정의
    			Runnable runnable = new Runnable() {
    				@Override
    				public void run() {
    					// 스레드 총 개수 및 작업 스레드 이름 출력
    					ThreadPoolExecutor threadPoolExcutor = 
    							(ThreadPoolExecutor) executorService;
    					int poolSize = threadPoolExcutor.getPoolSize();
    					String threadName = Thread.currentThread().getName();
    					System.out.println("[ 총 스레드 개수 : " + poolSize + 
    							" ] 작업 스레드 이름 : " + threadName);
    					
    					// 예외 발생 시킴
    					int value = Integer.parseInt("삼");
    				}
    			};	
    			// 작업 처리 요청
    			executorService.execute(runnable);
    			//executorService.submit(runnable);
    			
    			Thread.sleep(10);  // 콘솔에 출력 시간을 주기 위해 0.01초 일시 정지시킴
    		}
    		// 스레드풀 종료
    		executorService.shutdown();
    	}
    }
    ```
    
    ### `execute()` 메소드의 경우
    
    ![Untitled](/images/lang_java/multi_thread/스레드풀,_작업_생성과_처리_요청/Untitled%202.png)
    
    - 스레드풀의 스레드 최대 개수 2는 변함이 없다.
    - 실행 스레드의 이름을 보면 모두 다른 스레드가 작업을 처리하고 있다.
        - 이것은 작업 처리 도중 예외가 발생했기 때문에 해당 스레드는 제거되고 새 스레드가 계속 생성되기 때문
    
    ### `submit()` 메소드의 경우
    
    ![Untitled](/images/lang_java/multi_thread/스레드풀,_작업_생성과_처리_요청/Untitled%203.png)
    
    - 예외가 발생하더라도 스레드가 종료되지 않고 계속 재사용되어 다른 작업을 처리한다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판