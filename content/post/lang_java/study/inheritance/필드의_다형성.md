---
title: "[Java] 필드의 다형성"
description: ""
date: "2022-08-04T20:00:45+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 다형성이란 동일한 타입을 사용하지만 당야한 결과가 나오는 성질
    
    ### 필드의 다형성
    
    - 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현
    - 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있다.
    
    ---
    
    - 프로그램은 수 많은 객체들이 서로 연결되고 각자의 역할을 하게 된다.
        - 이 객체들은 다른 객체들로 교체될 수 있어야 한다.
        - 이것을 구현하기 위해서는 상속과 오버라이딩, 그리고 타입 변환을 이용하는 것이다.
    - 부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용방법이 동일
    - 자식 클래스는 부모의 메소드를 오버라이딩해서 메소드의 실행 내용을 변경하여 더 우수한 실행 결과가 나오게 하는 것이 가능
    - 자식 타입을 부모 타입으로 변환하는 것이 가능
    
    ---
    
    - ex) 필드의 다형성 코드
        
        ```java
        class Car {
        	// 필드
        	Tire frontLeftTire = new Tire();
        	Tire frontRightTire = new Tire();
        	Tire backLeftTire = new Tire();
        	Tire backRightTire = new Tire();
        
        	// 메소드
        	void run() { ... }
        }
        ```
        
        - Car 클래스는 4개의 Tire 필드를 가지고 있다.
        - Car 클래스로부터 Car 객체를 생성하면 4개의 Tire 필드에 하나씩 Tire 객체가 들어가게 된다.
        - frontRightTire와 backLeftTire를 ATire와 BTire로 교체할 경우
            - 다음과 같이 코드를 사용하여 코드를 교체 가능
            
            ```java
            Car myCar = new Car();
            myCar.frontRightTire = new ATire();
            myCar.backLeftTire = new BTire();
            myCar.run();
            ```
            
            - Tire 클래스 타입인 frontRightTire와 backLeftTire는 원래 Tire 객체가 저장되어야 하지만, Tire 자식 객체가 저장되어도 문제가 없다.
                - 자식 타입은 부모 타입으로 자동 타입 변환이 되기 때문
                - frontRightTire와 backLeftTire에 Tire 자식 객체가 저장되어도 Car 객체는 Tire 클래스에 선언된 필드와 메소드만 사용하므로 문제가 없다.
                - ATire와 BTire는 부모인 Tire의 필드와 메소드를 가지고 있다.
            
            ---
            
        - Car 객체에 `run()` 메소드가 있고, `run()` 메소드는 각 Tire 객체의 `roll()` 메소드를 다음과 같이 호출한다고 가정
            
            ```java
            void run() {
            	frontLeftTire.roll();
            	frontRightTire.roll();
            	backRightTire.roll();
            	backLeftTire.roll();
            }
            ```
            
            - frontRightTire와 backLeftTire를 교체하기 전에는 Tire 객체의 `roll()` 메소드가 호출
                - ATire와 BTire로 교체가 되면 ATire와 BTire가 `roll()` 메소드를 재정의하고 있으므로 교체 이후에는 ATire와 BTire의 `roll()` 메소드가 호출
            - 이와 같이 자동 타입 변환을 이용해서 Tire 필드값을 교체함으로써 Car의 `run()` 메소드 수정 없이도 다양한 `roll()` 메소드의 실행 결과를 얻게 된다.
        
        ---
        

### 필드의 다형성 예제

- Tire.java
    - 필드
        - 최대 회전수(maxRotation)
            - 타이어의 수명
            - 최대 회전수에 도달하면 타이어에 펑크가 생김
        - 누적 회전수(accumulatedRotation)
            - 타이어가 1번 회전할 때마다 1씩 증가
            - 누적 회전수가 최대 회전수에 도달하면 타이어는 펑크가 남
        - 타이어의 위치(location)
            - 앞 왼쪽
            - 앞 오른쪽
            - 뒤 왼쪽
            - 뒤 오른쪽
    - Tire 클래스의 생성자는 타이어의 위치와 최대 회전수를 매개값으로 받아 각각 필드에 저장
    - `roll()` 메소드는 타이어를 1회전시키는 메소드로 1번 실행 할때마다 누적 회전수를 1씩 증가
        - 그런 다음 누적 회전수가 최대 회전수보다 작을 때에는 남은 회전수를 출력
        - 최대 회전수가 되면 펑크를 출력
        - `roll()` 메소드의 리턴 타입은 boolean
            - 정상 회전 시 true 리턴
            - 펑크 시 false 리턴
    
    ```java
    public class Tire {
    	// 필드
    	public int maxRotation;         // 최대 회전수(타이어 수명)
    	public int accumulatedRotation; // 누적 회전수
    	public String location;         // 타이어의 위치
    	
    	// 생성자
    	public Tire(String location, int maxRotation) {
    		this.location = location;
    		this.maxRotation = maxRotation;
    	}
    	
    	// 메소드
    	public boolean roll() {
    		++accumulatedRotation;	// 누적 회전수 1 증가
    		if(accumulatedRotation < maxRotation) {
    			System.out.println(location + " Tire 수명 : " 
    		                       + (maxRotation - accumulatedRotation) 
    		                       + "회");
    			return true;
    		} else {
    			System.out.println("*** " + location + " Tire 펑크 ***");
    			return false;
    		}
    	}
    }
    ```
    
- Car.java
    - 필드
        - 네 개의 타이어
    - Tire 객체를 생성할 때 타이어의 위치와 최대 회전수를 생성자의 매개값으로 지정
    - frontLeftTire 필드의 경우
        - 최대 회전수를 6으로 주어, 6 회전 시 타이어가 펑크가 나도록 지정
    - `run()` 메소드는 네 개의 타이어을 한 번씩 1회전시키는 메소드
    - 각가의 Tire 객체의 `roll()` 메소드를 호출해서 리턴값이 false가 되면 `stop()` 메소드를 호출, 해당 위치의 타이어 번호를 리턴
        - 타이어 번호는 타이어를 교체할 때 사용된다.
    - stop() 메소드는 타이어가 펑크가 날 때 자동차를 멈추는 메소드
    
    ```java
    public class Car {
    	// 필드
    	Tire frontLeftTire = new Tire("앞 왼쪽", 6);
    	Tire frontRightTire = new Tire("앞 오른쪽", 2);
    	Tire backLeftTire = new Tire("뒤 왼쪽", 3);
    	Tire backRightTire = new Tire("앞 오른쪽", 4);
    	
    	// 생성자
    	
    	// 메소드
    	int run() {
    		System.out.println("자동차가 달린다.");
    		if(frontLeftTire.roll() == false) { stop(); return 1;}
    		if(frontRightTire.roll() == false) { stop(); return 2;}
    		if(backLeftTire.roll() == false) { stop(); return 3;}
    		if(backRightTire.roll() == false) { stop(); return 4;}
    		return 0;
    	}
    	
    	void stop() {
    		System.out.println("자동차가 멈춥니다.");
    	}
    }
    ```
    
- ATire.java와 BTire.java
    - 이 두 클래스는 Tire 클래스를 상속받음
    - 생성자는 타이어의 위치, 최대 회전수를 매개값으로 받아서 부모인 Tire 클래스의 생성자를 호출할 때 넘겨주었다.
    - `roll()`메소드는 오버라이딩 되었음
        - 정상 회전과 펑크가 났을 때 출력하는 내용이 Tire 클래스의 `roll()` 메소드와 다르다.
    
    ```java
    public class ATire extends Tire{
    	// 필드
    	// 생성자
    	public ATire(String location, int maxRotation) {
    		super(location, maxRotation);
    	}
    	
    	// 메소드
    	@Override
    	public boolean roll() {
    		++accumulatedRotation;
    		if(accumulatedRotation < maxRotation) {
    			System.out.println(location + "ATire 수명 : " 
    		                       + (maxRotation - accumulatedRotation) 
    		                       + " 회");
    			return true;
    		} else {
    			System.out.println("*** " + location + " ATire 펑크 ***");
    			return false;
    		}
    	}
    }
    ```
    
    ```java
    public class BTire extends Tire{
    		// 필드
    		// 생성자
    		public BTire(String location, int maxRotation) {
    			super(location, maxRotation);
    		}
    		
    		// 메소드
    		@Override
    		public boolean roll() {
    			++accumulatedRotation;
    			if(accumulatedRotation < maxRotation) {
    				System.out.println(location + "BTire 수명 : " 
    			                       + (maxRotation - accumulatedRotation) 
    			                       + " 회");
    				return true;
    			} else {
    				System.out.println("*** " + location + " BTire 펑크 ***");
    				return false;
    			}
    		}
    }
    ```
    
- CarEx.java
    
    ```java
    public class CarEx {
    
    	public static void main(String[] args) {
    		Car car = new Car(); // Car 객체 생성
    		
    		for(int i = 1; i <= 5; i++) {
    			int problemLocation = car.run();
    			
    			switch(problemLocation) {
    				case 1:
    					System.out.println("앞 왼쪽 ATire로 교체");
    					car.frontLeftTire = new ATire("앞 왼쪽", 15);
    					break;
    				case 2:
    					System.out.println("앞 오른쪽 BTire로 교체");
    					car.frontRightTire = new BTire("앞 오른쪽", 13);
    					break;
    				case 3:
    					System.out.println("뒤 왼쪽 ATire로 교체");
    					car.backLeftTire = new ATire("뒤 왼쪽", 14);
    					break;
    				case 4:
    					System.out.println("뒤 오른쪽 BTire로 교체");
    					car.backRightTire = new BTire("뒤 오른쪽", 17);
    					break;
    			}
    			System.out.println("--------------------------------");
    		}
    
    	}
    
    }
    ```
    
    ![Untitled](/images/lang_java/inheritance/필드의_다형성/Untitled.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판