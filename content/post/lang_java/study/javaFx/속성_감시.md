---
title: "[Java] JavaFX, 속성 감시"
description: ""
date: "2022-12-16T22:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "JavaFX"

---
<!--more-->

- JavaFX는 컨트롤의 속성(property)을 감시하는 리스너를 설정할 수 있다.
    - ex) Slider의 value 속성값을 감시하는 리스너를 설정
        - value 속성값이 변경되면 리스너가 다른 컨트롤러의 폰트나 이미지의 크기를 변경 가능

---

- JavaFX 컨트롤 속성은 세 가지 메소드로 구성
    - Getter와 Setter, Property 객체를 리턴하는 메소드
    
    ex) text 속성은 `getText()`, `setText(String newValue)` 그리고 StringProperty를 리턴하는 `textProperty()`를 가지고 있다.
    
    ```java
    private StringProperty text = new SimpleStringProperty();    // 값이 저장될 필드
    public void setText(String newValue) { text.set(newValue); } // Setter
    public String getText() { return text.get(); }               // Getter
    public StringProperty textProperty() { return text; }        // Property 메소드
    ```
    
- `StringProperty()`는 `get()`과 `set()` 메소드 이외의 리스너를 관리하는 메소드를 가지고 있다.
    - text 속성을 감시하는 리스너는 `textProperty()`가 리턴하는 StringProperty에서 설정
    
    ex) text 속성값을 감시하는 ChangeListener를 설정하는 코드
    
    ```java
    textProperty().addListener(new ChangeListener<String> {
    	@Override
    	public void changed(ObservableValue<? extends String> observable,
    													String oldValue, String newValue){
    	}
    });
    ```
    
    - `addListener()` 메소드가 ChangeListener를 Property 객체에 설정하면, text 속성이 변경되었을 때 ChangeListener의 `changed()` 메소드가 자동으로 실행된다.
    - 속성의 이전 값은 oldValue에, 새로운 값은 newValue에 매개값으로 전달
    - ChangeListener는 제네릭 타입
        - 타입 파라미터는 속성의 타입이 된다.
        
        ex) `textProperty()`가 리턴하는 StringProperty는 `Property<String>`을 구현하고 있기 때문에 타입 파라미터는 속성의 타입이 된다.
        
        - 따라서 oldValue와 newValue의 타입은 String이 된다.
    
    ex) Slider의 value 속성에 리스너를 설정하려는 경우
    
    ```java
    Slider slider = new Slider();
    slider.valueProperty().addListener( new ChangeListener<Number>() {
    	@Override
    	public void changed(ObservableValue<? extends Number> observable, 
                          Number oldValue, Number newValue) {
      }
    });
    ```
    
    - `valueProperty()`가 리턴하는 DoubleProperty가 `Property<Number>`를 구현하고 있기 때문에 ChangeListener의 타입 파라미터는 Number가 된다.
        - 따라서 oldValue와 newValue의 타입도 Number가 된다.
- JavaFX API 도큐먼트를 보면 `java.beans.property` 패키지에는 StringProperty, DoubleProperty 이외에도 다양한 Property 구현 클래스가 존재하는 것을 알 수 있다.
- ex) Slider의 value 속성을 감시해서 value 속성값이 변경되면 Label의 폰트 크기를 변경하도록 리스너를 설정
    - Label과 Slider 컨트롤을 배치
        - Root.fxml
        
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        
        <?import javafx.scene.control.*?>
        <?import javafx.scene.layout.*?>
        <?import javafx.scene.text.Font?>
        
        <BorderPane prefHeight="250.0" prefWidth="350.0" 
        			xmlns:fx="http://javafx.com/fxml/1" 
        			xmlns="http://javafx.com/javafx/19" 
        			fx:controller="listener.RootController">
           <center>
              <Label fx:id="label" text="JavaFX" BorderPane.alignment="CENTER" />
           	  	<font>
           	  		<Font size="0" /> <!-- Label의 기본 폰트 크기는 0 -->
           	  	</font>
           </center>
           <bottom>
              <Slider fx:id="slider" BorderPane.alignment="CENTER" />
           </bottom>
        </BorderPane>
        ```
        
    - 속성 감시 리스너 설정
        - RootController.java
        
        ```java
        import java.net.URL;
        import java.util.ResourceBundle;
        
        import javafx.beans.value.ChangeListener;
        import javafx.beans.value.ObservableValue;
        import javafx.fxml.FXML;
        import javafx.fxml.Initializable;
        import javafx.scene.control.Label;
        import javafx.scene.control.Slider;
        import javafx.scene.text.Font;
        
        public class RootController implements Initializable {
        	@FXML private Slider slider;
        	@FXML private Label label;
        	
        	@Override
        	public void initialize(URL location, ResourceBundle resources) {
        		slider.valueProperty().addListener(new ChangeListener<Number>() {
        			@Override
        			public void changed(ObservableValue<? extends Number> observable, 
        					Number oldValue, Number newValue) {
        				label.setFont(new Font(newValue.doubleValue()));
        				//Label의 폰트 변경      // Slider의 변경된 Value 값
        			}
        		});
        	}
        }
        ```
        
    - AppMain.java
        
        ```java
        import javafx.application.Application;
        import javafx.fxml.FXMLLoader;
        import javafx.scene.Parent;
        import javafx.scene.Scene;
        import javafx.stage.Stage;
        
        public class AppMain extends Application {
        	@Override
        	public void start(Stage primaryStage) throws Exception {
        		Parent parent = FXMLLoader.load(getClass().getResource("Root.fxml"));
        		Scene scene = new Scene(parent);
        		
        		primaryStage.setTitle("AppMain");
        		primaryStage.setScene(scene);
        		primaryStage.show();
        	}
        
        	public static void main(String[] args) {
        		launch(args);
        
        	}
        
        }
        ```
        
    
    ![Untitled](/images/lang_java/javaFx/속성_감시/Untitled.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판