---
title: "[Java] 중첩 클래스의 접근 제한"
description: ""
date: "2022-08-16T20:30:45+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

## 바깥 필드와 메소드에서 사용 제한

---

- 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다.
- ex) 바깥 필드와 메소드에서 사용 제한
    - A.java
        - 인스턴스 멤버 클래스(B)는 바깥 클래스의 인스턴스 필드(field1)의 초기값이나 인스턴스 메소드(`method1()`)에서 객체를 생성 가능
        - 정적 필드(field3)의 초기값이나 정적 메소드(`method2()`)에서는 객체 생성 불가
        - 정적 멤버 클래스(C)는 모든 필드의 초기값이나 모든 메소드에서 객체를 생성 가능
        
        ```java
        public class A {
        	// 인스턴스 필드
        	B field1 = new B(); // (o)
        	C field2 = new C(); // (o)
        	
        	// 인스턴스 메소드
        	void method1() {
        		B var1 = new B(); // (o)
        		C var2 = new C(); // (o)
        	}
        
        	// 정적 필드 초기화
        	//static B field3 = new B(); // (x)
        	static C field4 = new C();   // (o)
        
        	// 정적 메소드
        	static void method2(){
        		//B var1 = new B(); // (x)
        		C var2 = new C();   // (o)
        	}
        
        	// 인스턴스 멤버 클래스
        	class B {}
        
        	// 정적 멤버 클래스
        	static class C {}
        }
        ```
        
    
    ---
    

## 멤버 클래스에서 사용 제한

- 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때에도 제한이 다른다.
- 인스턴스 멤버 클래스(B) 안에서는 바깥 클래스의 모든 필드와 모든 메소드에 접근 가능
- 정적 멤버 클래스(C) 안에서는 바깥 클래스의 정적 필드(field2)와 메소드(`method2()`)에만 접근 가능
    - 인스턴스 필드(field1)와 메소드(`method1()`)는 접근 불가
    
    ![Untitled](/images/lang_java/nestedClassAndNestedInterface/중첩_클래스의_접근_제한/Untitled.png)
    
- ex) 멤버 클래스에서 사용 제한
    - A.java
        
        ```java
        public class A {
        	int field1;
        	void method1() { }
        
        	static int field2;
        	static void method2() { }
        
        	class B { 
        		void method() { // 모든 필드와 메소드에 접근 가능
        			field1 = 10;
        			method1();
        
        			field2 = 10;
        			method2();
        		}
        	}
        
        	static class C {
        		void method() { // 인스턴스 필드와 메소드는 접근 불가
        			//field1 = 10;
        			//method1();
        
        			field2 = 10;
        			method2();
        		}
        	}
        }
        ```
        
    
    ---
    

## 로컬 클래스에서 사용 제한

- 로컬 클래스 내부에서는 바깥 클래스의 필드와 메소드를 제한 없이 사용 가능

### 문제는 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때

- 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용될 수 있다.
- 매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라지기 때문에 로컬 객체에서 사용할 경우 문제가 발생

---

- 자바는 이 문제를 해결하기 위해 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해 두고 사용
- 매개 변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해 둔 값과 달라지는 문제를 해결하기 위해 매개 변수나 로컬 변수를 final로 선언해서 수정을 막는다.
    
    ### 로컬 클래스에서 사용 가능한 것은 `final`로 선언된 매개 변수와 로컬 변수뿐이다.
    
    - 자바 8부터는 `final` 키워드없이 선언된 매개 변수와 로컬 변수를 사용해도 컴파일 에러가 나지 않는다.
    - `final` 선언을 하지 않아도 여전히 값을 수정할 수 없는 `final`의 특성을 갖는다는 것
    - `final` 키워드 존재 여부의 차이점은 로컬 클래스의 복사 위치
        - final 키워드가 있다면 로컬 클래스의 메소드 내부에 지역 변수로 복사된다.
        - final 키워드가 없다면 로컬 클래스의 필드로 복사된다.
    
    ![Untitled](/images/lang_java/nestedClassAndNestedInterface/중첩_클래스의_접근_제한/Untitled%201.png)
    
    - 로컬 클래스에서 사용된 매개 변수의 로컬 변수는 모두 `final` 특성을 갖는다.

---

- ex) 로컬 클래스에서 사용 제한
    - Outter.java
        
        ```java
        public class Outter {
        
        	// 자바 7 이전
        	public void method1(final int arg) {
        		final int localVariable = 1;
        		//arg = 100; // (x)
        		//localVarable = 100; // (x)
        		
        		class Inner{
        			public void method() {
        				int result = arg + localVariable;
        			}
        		}
        	}
        	
        	// 자바 8 이후
        	public void method2(int arg) {
        		final int localVariable = 1;
        		//arg = 100; // (x)
        		//localVarable = 100; // (x)
        		
        		class Inner{
        			public void method() {
        				int result = arg + localVariable;
        			}
        		}
        	}
        }
        ```
        
    
    ---
    

## 중첩 클래스에서 바깥 클래스 참조 얻기

- 클래스 내부에서 `this`는 객체 자신의 참조
- 중첩 클래스에서 `this` 키워드를 사용하면 바깥 클래스의 객체 참조가 아니라, 중첩 클래스의 객체 참조가 된다.
- 중첩 클래스 내부에서 `this.필드`, `this.메소드()`로 호출라면 중첩 클래스의 필드와 메소드가 사용된다.
    - 중첩 클래스 내부에서 바깥 클래스의 객체 참조를 얻으려면 바깥 클래스의 이름을 `this` 앞에 붙여주면 된다.
    
    ```java
    바깥클래스.this.필드
    바깥클래스.this.메소드();
    ```
    
- ex)
    - Outter.java
        - 중첩 클래스에서 바깥 클래스 참조 얻기
        
        ```java
        public class Outter {
        
        	String field = "Outter - field";
        	
        	void method() {
        		System.out.println("Outter - method");
        	}
        	
        	class Nested{
        		String field = "Nested - field";
        		void method() {
        			System.out.println("Nested - method");
        		}
        		
        		void print() {
        			System.out.println(this.field); // 중첩 객체 참조
        			this.method();
        			System.out.println(Outter.this.field); // 바깥 객체 참조
        			Outter.this.method();
        		}
        	}
        }
        ```
        
    - OutterEx.java
        - 실행 클래스
        
        ```java
        public class OutterEx {
        
        	public static void main(String[] args) {
        		Outter outter = new Outter();
        		Outter.Nested nested = outter.new Nested();
        		nested.print();
        
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/중첩_클래스의_접근_제한/Untitled%202.png)
        

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판