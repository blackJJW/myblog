---
title: "[Java] 익명 객체"
description: ""
date: "2022-08-20T20:30:45+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 익명(anonymous) 객체는 이름이 없는 객체
- 익명 객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성 가능
- 필드의 초기값이나 로컬 변수의 초기값, 매개 변수의 매개값으로 주로 대입된다.
- UI 이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 익명 객체가 많이 활용

---

## 익명 자식 객체 생성

---

- 부모 타입으로 필드나 변수를 선언, 자식 객체를 초기값으로 대입할 경우
    1. 부모 클래스를 상속해서 자식 클래스를 선언
    2. `new` 연산자를 이용해서 자식 객체를 생성
    3. 필드나 로컬 변수에 대입
    
    ```java
    class Child extends Parent { }   // 자식 클래스 선언
    
    class A {
    	Parent field = new Child();   // 필드에 자식 객체를 대입
    	void method() {
    		Parent localVar = new Child();   // 로컬 변수에 자식 객체를 대입
    	}
    }
    ```
    
- 자식 클래스가 재사용되지 않고, 오로지 해당 필드와 변수의 초기값으로만 사용할 경우
    - 익명 자식 객체를 생성해서 초기값으로 대입하는 것이 좋은 방법
- 익명 자식 객체를 생성하는 방법
    - 주의할 점 : 하나의 실행문이므로 끝에는 세미콜론( ; )을 붙여야 한다.
    
    ```java
    부모클래스 [필드 | 변수] = new 부모클래스(매개값, ... ) {
    	// 필드
    	// 메소드
    };
    ```
    
    - `부모클래스(매개값, … ) { }`은 부모 클래스를 상속해서 중괄호 `{ }`와 같이 자식 클래스를 선언하라는 뜻
    - `new` 연산자는 이렇게 선언된 자식 클래스를 객체로 생성
    - `부모클래스(매개값, …)`은 부모 생성자를 호출하는 코드
        - 부모 생성자의 매개 변수에 맞게 입력
    - 중괄호 `[ }` 내부에는 필드나 메소드를 선언하거나 부모 클래스의 메소드를 오버라이드하는 내용이 온다.
    - 일반 클래스와의 차이점은 생성자를 선언할 수 없다는 점
    
    ---
    
- 필드를 선언할 때 초기값으로 익명 자식 객체를 생성해서 대입
    
    ```java
    class A {
    	Parent field = new Parent() {   // A클래스의 필드 선언
    		int childField;
    		void childMethod() { }
    
    		@Override   // Parent의 메소드를 오버라이딩
    		void parentMethod() { }
    	}
    }
    ```
    
- 메소드 내에서 로컬 변수를 선언할 때 초기값으로 익명 자식 객체를 생성해서 대입
    
    ```java
    class A {
    	void method() {     // 로컬 변수 선언
    		Parent localVar = new Parent() {
    			int childField;
    			void childMethod() { }
    
    			@Override   // Parent의 메소드를 오버라이딩
    			void parentMethod() { }
    		}
    	}
    }
    ```
    
- 메소드의 매개 변수가 부모 타입일 경우 메소드 호출 코드에서 익명 자식 객체를 생성해서 매개값으로 대입 가능
    
    ```java
    class A {
    	void method1(Parent parent) { }
    
    	void method2() {
    		method1(   // method1() 메소드 호출
    			new Parent() {   // method1()의 매개값으로 익명 자식 객체를 대입
    				int childField;
    				void childMethod() { }
    				
    				@Override
    				void parentMethod() { }
    			}
    		);
    	}
    }
    ```
    
- 익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명 자식 객체 내부에서만 사용
    - 외부에서는 필드와 메소드에는 접근 불가
    - 익명 자식 객체는 부모 타입 변수에 대입되므로 타입에 선언된 것만 사용 가능하기 때문
    - ex) 필드 childField와 메소드 `childMethod()`는 `parentMethod()` 메소드 내에서 사용이 가능
        - A 클래스의 필드인 field로는 접근이 불가
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled.png)
        
    
    ---
    
- ex)
    - Person.java
        - 부모 클래스
        
        ```java
        public class Person {
        
        	void wake() {
        		System.out.println("7시에 일어남");
        	}
        }
        ```
        
    - Anonymous.java
        - 익명 자식 객체 생성
        
        ```java
        public class Anonymous {
        
        	// 필드 초기값으로 대입
        	Person field = new Person() { // 필드 선언돠 초기값 대입
        		void work() {
        			System.out.println("출근");
        		}
        		@Override
        		void wake() {
        			System.out.println("6시에 일어남");
        			work();
        		}
        	};
        	
        	void method1() {
        		// 로컬 변수값으로 대입
        		Person localVar = new Person() { // 로컬 변수 선언과 초기값 대입
        			void walk() {
        				System.out.println("산책");
        			}
        			@Override
        			void wake() {
        				System.out.println("7시에 일어남");
        				walk();
        			}
        		};
        		// 로컬 변수 사용
        		localVar.wake();
        	}
        	
        	void method2(Person person) {
        		person.wake();
        	}
        }
        ```
        
    - AnnoymousEx.java
        - 익명 자식 객체 생성
        
        ```java
        public class AnonymousEx {
        
        	public static void main(String[] args) {
        		Anonymous anony = new Anonymous();
        		
        		// 익명 객체 필드 사용
        		anony.field.wake();
        		
        		// 익명 객체 로컬 변수 사용
        		anony.method1();
        		
        		// 익명 객체 매객값 사용
        		anony.method2(
        				new Person() { // 매개값
        					void study() {
        						System.out.println("공부");
        					}
        					@Override
        					void wake() {
        						System.out.println("8시에 일어남");
        						study();					}
        				}
        			);
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled%201.png)
        
    
    ---
    

## 익명 구현 객체 생성

---

- 인터페이스 타입으로 필드나 변수를 선언하고, 구현 객체를 초기값으로 대입하는 경우
    - 구현 클래스를 선언
    - `new` 연산자를 이용해서 구현 객체를 생성
    - 필드나 로컬 변수에 대입하는 것이 기본
    
    ```java
    class TV implements RemoteControl { }
    
    class A {
    	RemoteControl field = new TV();   // 필드에 구현 객체를 대입
    	void method() {
    		RemoteControl localVar = new TV();   // 로컬 변수에 구현 객체를 대입
    	}
    }
    ```
    
- 구현 클래스가 재사용되지 않고, 오로지 해당 필드와 변수의 초기값으로만 사용되는 경우
    - 익명 구현 객체를 초기값으로 대입하는 것이 좋다.
    
    ```java
    인터페이스 [필드 | 변수] = new 인터페이스() {
    	// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
    	// 필드
    	// 메소드
    };
    ```
    
    - `인터페이스() {}`는 인터페이스를 구현해서 중괄호 `{}`와 같이 클래스를 선언하라는 의미
        - `new` 연산자는 이렇게 선언된 클래스를 객체로 생성
        - 중괄호`{}`에는 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야 한다.
            - 그렇지 않을 경우 컴파일 에러 발생
        - 추가적으로 필드와 메소드를 선언 가능
            - 실체 메소드에만 사용이 가능하고 외부에서는 사용 불가능
    
    ---
    
- ex) 필드를 선언할 때 초기값으로 익명 구현 객체를 생성해서 대입
    
    ```java
    class A {
    	RemoteControl field = new RemoteControl() { // 클래스 A의 필드 선언
    		@Override     // Remotecontrol 인터페이스의 추상 메소드에 대한 실체 메소드
    		void turnOn() { }
    	};
    }
    ```
    
- ex) 메소드 내에서 로컬 변수를 선언할 때 초기값으로 익명 구현 객체를 생성해서 대입
    
    ```java
    vodi method() {
    	RemoteControl localVar = new RemoteControl() { // 로컬 변수 선언
    		@Override    // RemoteControl 인터페이스의 추상 메소드에 대한 실체 메소드
    		void turnOn() { }
    	}
    }
    ```
    
- ex) 메소드의 매개 변수가 인터페이스 타입일 경우
    - 메소드 호출 코드에서 익명 구현 객체를 생성해서 매개값으로 대입 가능
    
    ```java
    class A {
    	void method1(RemoteConstrol rc) { }
    
    	void method2() {
    		method1(    // method1() 메소드 호출
    			new RemoteControl() {   // method1()의 매개값으로 익명 구현 객체를 대입
    				@Override
    				void turnOn() { }
    			}
    		);
    	}
    }
    ```
    
    - RemoteControl.java
        - 인터페이스
        
        ```java
        public interface RemoteControl {
        
        	public void turnOn();
        	public void turnOff();
        }
        ```
        
    - Annoymous.java
        - 익명 구현 클래스와 객체 생성
        
        ```java
        public class Annonymous {
        
        	// 필드 초기값으로 대입
        	RemoteControl field = new RemoteControl() { // 필드 선언과 초기값 대입
        		@Override
        		public void turnOn() {
        			System.out.println("TV On");
        		}
        		@Override
        		public void turnOff() {
        			System.out.println("TV Off");
        		}
        	};
        	
        	void method1() {
        		// 로컬 변수값으로 대입
        		RemoteControl localVar = new RemoteControl() { // 로컬 병수 선언과 초기값 대입
        			@Override
        			public void turnOn() {
        				System.out.println("Audio On");
        			}
        			@Override
        			public void turnOff() {
        				System.out.println("Audio Off");
        			}
        		};
        		// 로컬 변수 사용
        		localVar.turnOn();
        	}
        	void method2(RemoteControl rc) {
        		rc.turnOn();
        	}
        }
        ```
        
    - AnnonymousEx.java
        - 익명 구현 클래스와 객체 생성
        
        ```java
        public class AnnoymousEx {
        
        	public static void main(String[] args) {
        		Annonymous annony = new Annonymous();
        		// 익명 객체 필드 사용
        		annony.field.turnOn();
        		// 익명 객체 로컬 변수 사용
        		annony.method1();
        		// 익명 객체 매개값 사용
        		annony.method2(
        				new RemoteControl() {  // 매개값
        					@Override
        					public void turnOn() {
        						System.out.println("Smart TV On");
        					}
        					@Override
        					public void turnOff() {
        						System.out.println("Smart TV Off");
        					}
        				}
        		);
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled%202.png)
        
    
    ---
    
- ex) UI 프로그램에서 흔히 사용되는 버튼의 클릭 이벤트 처리를 익명 구현 객체를 이용해서 처리하는 방법
    - Button.java
        - UI 클래스
        
        ```java
        public class Button {
        
        	OnClickListener listener;  // 인터페이스 타입 필드
        	
        	void setOnClickListener(OnClickListener listener) { // 매개변수의 다형성
        		this.listener = listener;                   
        	}
        	
        	void touch() {   // 구현 객체의 onClick() 메소드 호출
        		listener.onClick();
        	}
        	
        	interface OnClickListener{ // 중첩 인터페이스
        		void onClick();
        	}
        }
        ```
        
        - 중첩 인터페이스(OnClickListener) 타입으로 필드(listener)를 선언
        - Setter 메소드(`setOnClickListener()`)로 외부에서 구현 객체를 필드에 대입
        - 버튼 이벤트가 발생할 경우(`touch()` 메소드가 실행될 때)
            - 인터페이스를 통해 구현 객체의 메소드를 호출(`listener.onClick()`)
    - Window.java
        - UI 클래스
        - 두 개의 Button 객체를 가지고 있는 윈도우 창을 생성하는 클래스
        - 첫 번째 button1의 클릭 이벤트 처리는 필드로 선언한 익명 구현 객체가 담당
        - 두 번째 button2의 클릭 이벤트 처리는 `setOnClickListener()`를 호출할 때 매개값으로 준 익명 구현 객체가 담당
        
        ```java
        public class Window {
        
        	Button button1 = new Button();
        	Button button2 = new Button();
        	
        	// 필드 초기값으로 대입
        	Button.OnClickListener listener = new Button.OnClickListener() {
        		@Override
        		public void onClick() {
        			System.out.println("전화를 건다.");
        		}
        	};
        	
        	Window(){
        		button1.setOnClickListener(listener); // 매개값으로 필드 대입
        		button2.setOnClickListener(new Button.OnClickListener() {
        			// 매개값으로 익명 구현 객체 대입
        			@Override
        			public void onClick() {
        				System.out.println("메세지를 보낸다.");
        				
        			}
        		});
        	}
        }
        ```
        
    - Main.java
        - 실행 클래스
        
        ```java
        public class Main {
        
        	public static void main(String[] args) {
        		Window w = new Window();
        		w.button1.touch(); // 버튼 클릭
        		w.button2.touch(); // 버튼 클릭
        
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled%203.png)
        
    
    ---
    

## 익명 객체의 로컬 변수 사용

---

- 익명 객체 내부에서는 바깥 클래스의 필드나 메소드는 제한없이 사용 가능
- 메소드의 매개 변수나 로컬 변수를 익명 객체에서 사용할 때 문제 발생
    - 메소드 내에서 생성된 익면 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용 가능
    - 매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라지기 때문에 익명 객체에서 사용할 수 없게 되므로 문제가 발생
- 익명 객체 내부에서 메소드의 매개 변수나 로컬 변수를 사용할 경우
    - 변수들은 `final` 특성을 가져야 한다.
        - 자바 7 이전까지는 반드시 `final` 키워드로 이 변수들을 선언해야 한다.
        - 자바 8 이후부터는 `final` 키워드 없이 선언해도 좋다.
            - `final` 선언을 하지 않아도 여전히 값을 수정할 수 없는 `final` 특성을 갖기 때문
    - 컴파일 시 `final` 키워드가 있다면 메소드 내부에서 지역 변수로 복사된다.
        - `final` 키워드가 없다면 익명 클래스의 필드로 복사된다.

![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled%204.png)

- ex) 매개 변수와 로컬 변수가 익명 객체에서 사용할 때 `final` 특성을 갖는다.
    - Calculatable.java
        - 인터페이스
        
        ```java
        public interface Calculatable {
        
        	public int sum();
        }
        ```
        
    - Anonymous.java
        - 익명 객체의 로컬 변수 사용
        
        ```java
        public class Anonymous {
        
        	private int field;
        	
        	public void method(final int arg1, int arg2) {
        		final int var1 = 0;
        		int var2 = 0;
        		
        		field = 10;
        		
        		//arg1 = 20; //(x)
        		//arg2 = 20; //(x)
        		
        		//var1 = 30; //(x)
        		//var2 = 30; //(x)
        		
        		Calculatable calc = new Calculatable() {
        			@Override
        			public int sum() {
        				int result = field + arg1 + arg2 + var1 + var2;
        				return result;
        			}
        		};
        		
        		System.out.println(calc.sum());
        	}
        }
        ```
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled%205.png)
        
    - AnonymousEx.java
        
        ```java
        public class AnonymousEx {
        
        	public static void main(String[] args) {
        		Anonymous anony = new Anonymous();
        		anony.method(0, 0);
        
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/nestedClassAndNestedInterface/익명_객체/Untitled%206.png)
        

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판