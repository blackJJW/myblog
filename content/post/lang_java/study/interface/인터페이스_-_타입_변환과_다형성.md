---
title: "[Java] 인터페이스 - 타입 변환과 다형성"
description: ""
date: "2022-08-14T18:00:45+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 인터페이스도 다형성을 구현하는 기술이 사용
- 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질
- 부모 타입에 어떤 자식 객체를 대입하느냐에 따라 실행 결과가 달라진다.

---

- 프로그램 개발 시 인터페이스를 사용해서 메소드를 호출하도록 작성했다면, 구현 객체를 교체하는 것은 빠르게 할 수 있다.
- 프로그램 소스 코드는 변함이 없는 데, 구현 객체를 교체함으로써 프로그램의 실행 결과가 다양해진다.
    - 이것이 인터페이스의 다형성
    
    ---
    
- ex) I 인터페이스를 이용해서 프로그램을 개발
    - I 인터페이스를 구현할 클래스로 처음에는 A 클래스를 선택
    - 개발 완료 후, 테스트를 진행해보니 A 클래스에 문제가 생겨 다른 클래스를 사용해야 한다.
    - 이런 경우 I 인터페이스를 구현한 B 클래스를 만들고 한 줄만 수정하여 프로그램을 재 실행할 수 있다.
    
    ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled.png)
    
    ---
    
- 인터페이스는 메소드의 매개 변수로 많이 등장
    - 인터페이스 타입으로 매ㅐㄱ 변수를 선언하면 메소드 호출 시 매개값으로 여러 가지 종류의 구현 객체를 줄 수 있기 때문에 메소드 실행 결과가 다양하게 나온다.
        - 이것이 인터페이스 매개 변수의 다형성
    - ex) `useRemoteControl()` 메소드의 매개 변수가 RemoteControl 인터페이스 타입일 경우
        - 매개값으로 Television 객체 또는 Audio 객체를 선택적으로 줄 수 있다.
        
        ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled%201.png)
        
        - 메소드 호출 시 어떤 구현 객체를 매개값으로 주느냐에 따라서 `useRemoteControl()` 메소드의 실행 결과는 다르게 나온다.
    
    ---
    

## 자동 타입 변환(Promotion)

- 구현 객체가 인터베이스 타입으로 변환되는 것은 자동 타입 변환(Promotion)에 해당
- 자동 타입 변환은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것
    
    ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled%202.png)
    
- 인터페이스 구현 클래스를 상속해서 자식 클래스르 만드럿다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환 가능
    
    ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled%203.png)
    
- 자동 타입 변환을 이용하면 필드의 다형성과 매개 변수의 다형성을 구현할 수 있다.
- 필드와 매개 변수의 타입을 인터페이스로 선언하면 여기에 다양한 구현 객체를 대입해서 실행 결과를 다양하게 만들 수 있다.

---

## 필드의 다형성

- 상속에서의 다형성과 유사
- 타이어가 클래스 타입이 아니라 인터페이스
- ATire와 BTire는 자식 클래스가 아니라 구현 클래스
    - ATire와 BTire는 공통적으로 타이어 인터페이스를 구현했기 때문에 모두 타이어 인터페이스에 있는 메소드를 가지고 있다.
    - 타이어 인터페이스로 동일하게 사용할 수 있는 교체 가능한 객체에 해당
    
    ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled%204.png)
    
    - 자동차를 설계할 때 필드 타입으로 타이어 인터페이스를 선언하게 되면 필드값으로 ATire 또는 BTire 객체를 대입할 수 있다.
        - 자동 타입 변환이 일어나기 때문에 아무런 문제가 없다.
        
        ```java
        public class Car {
        	Tire frontLeftTire = new ATire();
        	Tire frontRightTire = new ATire();
        	Tire backLeftTire = new ATire();
        	Tire backRightTire = new ATire();
        }
        ```
        
    - Car 객체를 생성한 후, 초기값으로 대입한 구현 객체 대신 다른 구현 객체를 대입 가능
        - 이것이 타이어 교체에 해당
        
        ```java
        Car myCar = new Car();
        myCar.frontLeftTire = new BTire();
        myCar.frontRightTire = new BTire();
        ```
        
        - frontLeftTire와 frontRightTire에 어떠한 타이어 구현 객체가 저장되어도 Car 객체는 타이어 인터페이스에 선언된 메소드만 사용하므로 문제가 없다.
    - Car 객체의 `run()` 메소드에서 타이어 인터페이스에 선언된 `roll()`메소드를 호출
        
        ```java
        void run() {
        	frontLeftTire.roll();
        	frontRightTire.roll();
        	backLeftTire.roll();
        	backRightTire.roll(); 
        }
        ```
        
    - frontLeftTire와 frontRightTire를 교체하기 전에는 ATire 객체의 `roll()` 메소드가 호출되지만, BTire로 교체된 후에는 BTire 객체의 `roll()` 메소드가 호출된다.
        - Car의 `run()` 메소드 수정 없이도 다양한 `roll()` 메소드의 실행 결과를 얻을 수 있다.
            - 이것이 필드의 다형성
    
    ---
    
- ex) 필드의 다형성
    - Tire.java
        - 인터페이스
        
        ```java
        public interface Tire {
        
        	public void roll(); // roll() 메소드 호출 방법 설명 
        }
        ```
        
    - ATire.java
        - 구현 클래스
        
        ```java
        public class ATire implements Tire{
        
        	@Override
        	public void roll() { // Tire 인터페이스 구현
        		System.out.println("ATire가 굴러감");
        	}
        }
        ```
        
    - BTire.java
        - 구현 클래스
        
        ```java
        public class BTire implements Tire{
        
        	@Override
        	public void roll() { // Tire 인터페이스 구현
        		System.out.println("BTire가 굴러감");
        	}
        }
        ```
        
    - Car.java
        - 필드의 다형성
        
        ```java
        public class Car {
        
        	Tire frontLeftTire = new ATire(); // 인터페이스 타입 필드 선언과
        	Tire frontRightTire = new ATire();// 초기 구현 객체 타입
        	Tire backLeftTire = new ATire();
        	Tire backRightTire = new ATire();
        	
        	void run() {
        		frontLeftTire.roll(); // 인터페이스에서 설명된
        		frontRightTire.roll();// roll() 메소드 호출
        		backLeftTire.roll();
        		backRightTire.roll();
        	}
        }
        ```
        
    - CarEx.java
        - 필드 다형성 테스트
        
        ```java
        public class CarEx {
        
        	public static void main(String[] args) {
        
        		Car myCar = new Car();
        		
        		myCar.run();
        		
        		myCar.frontLeftTire = new BTire();
        		myCar.frontRightTire = new BTire();
        		
        		myCar.run();
        
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled%205.png)
        
    
    ---
    

## 인터페이스 배열로 구현 객체 관리

- 위의 예제, Car 클래스에서 4개의 타이어 필드를 인터페이스로 각각 선언
- 하지만, 다음과 같이 인터페이스 배열로 관리 가능
    
    ```java
    Tire[] tires = {
    	new ATire(),
    	new ATire(),
    	new ATire(),
    	new ATire()
    }
    ```
    
    - frontLeftTire : `tires[0]`
    - frontRightTire : `tires[1]`
    - backLeftTire : `tires[2]`
    - backRightTire : `tires[3]`
    - 인덱스로 표현되므로 대입이나 제어문에서 활용하기 쉽다.
        - ex) 앞 오른쪽 타이어를 BTire로 교체
            
            ```java
            tires[1] = new BTire();
            ```
            
    - tires 배열의 각 항목은 Tire 인터페이스 타입이므로, 구현 객체인 BTire를 대입하면 자동 타입 변환이 발생하기 때문에 아무런 문제가 없다.
    
    ---
    
- 구현 객체들을 배열로 관리하면 제어문에서 가장 이득
    - ex) 전체 타이어의 roll() 메소드를 호출하는 Car 클래스의 `run()` 메소드를 for문으로 작성
        
        ```java
        void run() {
        	for(Tire tire : tires) {
        		tire.roll();
        	}
        }
        ```
        
    
    ---
    
- ex) 위의 예제의 Car 클래스의 타이어 필드를 배열로 수정
    - Car.java
        - 필드 다형성
        
        ```java
        public class Car {
        
        	Tire[] tires = {
        			new ATire(),
        			new ATire(),
        			new ATire(),
        			new ATire()
        	};
        	
        	void run() {
        		for(Tire tire : tires) {
        			tire.roll();
        		}
        	}
        }
        ```
        
    - CarEx.java
        - 필드 다형성 테스트
        
        ```java
        public class CarEx {
        
        	public static void main(String[] args) {
        
        		Car myCar = new Car();
        		
        		myCar.run();
        		
        		myCar.tires[0] = new BTire();
        		myCar.tires[1] = new BTire();
        		
        		myCar.run();
        
        	}
        
        }
        ```
        
        ![Untitled](/images/lang_java/interface/인터페이스_-_타입_변환과_다형성/Untitled%206.png)
        

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판