---
title: "[Java] NIO, TCP 블로킹 채널, 채팅 서버 구현"
description: ""
date: "2023-02-02T21:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "JavaFX"
  - "Network"

---
<!--more-->

## 1. 서버 클래스 구조

- 채팅 서버
    - ServerEx.java
    
    ```java
    // JavaFX 메인 클래스로 만들기 위해 Application을 상속
    public class ServerEx extends Application {
    	// 스레드풀은 ExecutorService 필드를 선언
    	ExecutorService executorService;
    	
    	// 클라이언트의 연결을 수락하는 ServiceSocketChannel 필드를 선언
    	ServerSocketChannel serverSocketChannel;
    	
    	/* 연결된 클라이언트를 저장하는 List<Client> 타입의 
       * connections 필드를 선언
    	 * 스레드에 안전한 Vector로 초기화
       */
    	List<Client> connections = new Vector<Client>();
    
    	// startServer()는 서버 시작 시 호출되는 메소드
    	void startServer() { // 서버 시작 코드 }
    
    	// stopServer()는 서버 종료 시 호출되는 메소드
    	void stopServer() { // 서버 종료 코드 }
    
    	// Client 클래스는 연결된 클라이언트를 표현
    	// 데이터 통신을 포함
    	class Client { // 데이터 통신 코드 }
    
    	///////////////////////////////////
    	// UI 생성 코드는 레이아웃을 구성하고, ServerEx을 생성
    	// UI 생성 코드
    }
    ```
    
- 실행 화면에서 [start] 버튼을 클릭하면 `startServer()` 메소드가 호출
    - [start] 버튼은 [stop] 버튼으로 변경
- [stop] 버튼을 클릭하면 `stopServer()` 메소드가 호출
    - [stop] 버튼은 [start] 버튼으로 변경

## 2. `startServer()` 메소드

- [start] 버튼을 클릭하며 `startServer()` 메소드가 실행
    - startServer() 메소드
        - ExecutorService 생성
        - ServerSocketChannel 생성 및 포트 바인딩
        - 연결 수락 코드
- CPU 코어의 수에 맞게 스레드를 생성해서 관리하는 ExecutorService를 생성
    
    ```java
    void startServer() {
    	executorService = Executors.newFixedThreadPool(
    		Runtime.getRuntime().availableProcessors()
    	);
     ...
    }
    ```
    
- 5001번 포트에서 클라이언트의 연결을 수락하는 ServerSocketChannel을 생성
    
    ```java
    try {
    	serverSocketChannel = ServerSocketChannel.open();
    	serverSocketChannel.configureBlocking(true);
    	serverSocketChannel.bind(new InetSocketAddress(5001));
    } catch(Exception e) {
    	/* 5001번 포트를 이미 다른 포트 프로그램에서 사용하고 있다면
       * java.net.BindException이 발생
       * 이 경우에는 ServerSocketChannel이 열려 있는지 확인
       * stopServer() 메소드를 실행
       * return을 실행해서 startServer() 메소드를 종료
       */
    	if(serverSocketChannel.isOpen()) { stopServer(); }
    	return;
    }
    ```
    
- 연결 수락 작업을 Runnable 객체로 생성
    - 스레드풀의 작업 스레드로 실행시키는 코드
    - ServerSocketChannel은 반복해서 클라이언트 연결 요철을 기다려야 한다.
        - 스레드풀의 작업 스레드상에서 `accept()` 메소드를 반복적으로 호출해주어야 한다.
    
    ```java
    // 연결 수락 작업을 Runnable로 정의
    Runnable runnable = new Runnable() {
    	@Override
    	public void run() {
    		/* 작업 스레드는 UI를 변경하지 못하므로 
         * Platform.runLater가 사용
         * "[ 서버 시작 ]"을 출력하도록 displayText()를 호출
         * [start] 버튼의 글자를 [stop]으로 변경
         */ 
    		Platform.runLater(() -> {
    			displayText("[ 서버 시작 ]");
    			btnStartStop.setText("stop");
    		});
    
    		// 반복적으로 클라이언트의 연결을 수락하기 위해 무한 루프를 작성
    		while(true) {
    			try {
    				// 연결 수락
            /* ServerSocketChannel의 accept()를 실행해서
             * 클라이언트의 연결 요청을 기다림
             * 클라이언트가 연결 요청을 해오면 연결을 수락
             * 통신용 SocketChannel을 리턴
             */
    				SocketChannel socketChannel 
    						= serverSocketChannel.accept();
    				
            /* "[ 연결 수락 : 클라이언트IP : 작업스레드이름 ]"으로
             * 문자열을 생성
             * 출력하기 위해 displayText()를 호출
             */
    				String message = "[ 연결 수락 : " 
    						+ socketChannel.getRemoteAddress() 
    						+ " : " + Thread.currentThread().getName() 
    						+ " ]";
    				Platform.runLater(() -> displayText(message));
    
    				// Client 객체 저장
            /* SocketChannel로 Client 객체를 생성
             * connections 컬렉션에 추가
             */
    				Client client = new Client(socketChannel);
    				connections.add(client);
    
            /* "[ 연결 개수 : 현재 관리되고 있는 Client 객체 수 ]"로
             * 문자열을 생성
             * 출력하기 위해 displayText()를 호출
             */
    				Platform.runLater(() -> displayText("[ 연결 개수 : " 
    						+ connections.size() + " ]"));
    			} catch (Exception e) {
            /* accept()에서 예외가 발생하면 ServerSocketChannel이 
             * 열려있는지 확인, stopServer()를 호출
             * 무한 루프를 종료
             */
    				if(serverSocketChannel.isOpen()) { stopServer(); }
    				break;
    			}
    		}
    	}
    };
    // 스레드풀에서 처리
    /* 연결 수락 작업을 스레드풀에서 처리하기 위해
     * ExecutorService의 submit()을 호출
     */
    executorService.submit(runnable); 
    ```
    

## 3. `stopServer()` 메소드

- [stop] 버튼을 클릭하면 `stopServer()` 메소드가 실행
    - stopServer() 메소드
        - 연결된 모든 SocketChannel 닫기
        - ServerSocketChannel 닫기
        - ExecutorService 종료
    
    ```java
    void stopServer() {
    	try {
    		// 모든 SocketChannel 닫기
        // connections 컬렉션으로부터 반복자를 얻어냄
    		Iterator<Client> iterator = connections.iterator();
    
        /* while문으로 반복자를 반복하면서 Client를 하나씩 얻는다.
         * Client가 가지고 있는 SocketChannel을 닫고
         * connections 컬렉션에서 Client를 제거
         */
    		while(iterator.hasNext()) {
    			Client client = iterator.next();
    			client.socketChannel.close();
    			iterator.remove();
    		}
    		// ServerSocketChannel 닫기
        /* ServerSocketChannel이 null이 아니고,
         * 열려 있으면 ServerSocketChannel을 닫는다.
         */
    		if(serverSocketChannel != null 
             && serverSocketChannel.isOpen()) {
    			serverSocketChannel.close();
    		}
    		// ExecutorService 종료
        /* ExecutorService가 null이 아니고,
         * 종료 상태가 아니면 ExecutorService를 종료
         */
    		if(executorService != null 
             && !executorService.isShutdown()) {
    			executorService.shutdown();
    		}
        /* 작업 스레드는 UI를 변경하지 못하므로 
         * Platform.runLater()가 사용
         * "[ 서버 멈춤 ]"을 출력하도록 displayText()를 호출
         * [stop] 버튼의 글자를 [start]로 변경
         */
    		Platform.runLater(() -> {
    			displayText("[ 서버 멈춤 ]");
    			btnStartStop.setText("start");
    		});
    	} catch (Exception e) {}
    }
    ```
    

## 4. Client 클래스

- 서버는 다수의 클라이언트가 연결하기 때문에 클라이언트를 관리해야 한다.
- 클라이언트별로 고유한 데이터를 저장할 필요도 있기 때문에 Client 클래스를 작성
    - 연결 수락 시 마다 Client 인스턴스를 생성해서 관리하는 것이 좋다.
- Client 클래스에는 데이터 받기 및 보내기 코드가 포함
- Client 클래스의 구조
    
    ```java
    // Client를 ServerEx의 내부 클래스로 선언
    class Client {
      // 통신용 SocketChannel을 필드로 선언
    	SocketChannel socketChannel;
    
      /* Client 생성자를 선언
       * 매개값으로 SocketChannel 필드를 초기화
       * receive()를 호출
       */
    	Client(SocketChannel socketChannel) {
    		this.socketChannel = socketChannel;
    		receive();
    	}
    
      // 클라이언트의 데이터를 받기 위해 receive() 메소드를 선언
    	void receive() { 
    		// 데이터 받기 코드 
    	}
      // 데이터를 클라이언트로 보내기 위해 send() 메소드를 선언
    	void send(String data) { 
    		// 데이터 전송 코드 
    	}
    }
    ```
    
- 클라이언트의 데이터를 받는 `receive()` 메소드
    - 스레드풀의 작업 스레드가 처리하도록 Runnable로 작업을 정의
    - 클라이언트가 보낸 데이터를 반복적으로 받기 위해 무한 루프를 돌면서 SocketChannel의 `read()` 메소들를 호출
    
    ```java
    void receive() {
      // 클라이언트로부터 데이터를 받는 작업을 Runnable로 정의
    	Runnable runnable = new Runnable() {
        // run() 메소드를 재정의
    		@Override
    		public void run() {
          // 작업을 무한 반복
    			while(true) {
    				try {
              // 100개으이 바이트를 저장할 수 있는 ByteBuffer를 생성
    					ByteBuffer byteBuffer = ByteBuffer.allocate(100);
    
    					// 클라이언트가 비정상 종료를 했을 경우 IOException 발생
    					// 데이터 받기
              /* SocketChannel의 read() 메소드를 호출
               * 클라이언트가 데이터를 보내기 전까지 블로킹된다.
               * 데이터를 받으면 byteBuffer에 저장하고 받은 
               * 바이트 개수를 readByteCount에 저장
               */
    					int readByteCount = socketChannel.read(byteBuffer);
    
    					/* 클라이언트가 정상적으로 SocketChannel의 close()를 호출했을 경우
               * 위의 read() 메소드는 -1을 리턴
               * 이 경우 IOException을 강제로 발생
               */
    					if(readByteCount == -1) {
    						throw new IOException();
    					}
    
              // 정상적으로 데이터를 받게된 경우
    					String message = "[ 요청 처리 : " 
    						+ socketChannel.getRemoteAddress() + " : " 
    						+ Thread.currentThread().getName() + " ]";
    					Platform.runLater(() -> displayText(message));
    
    					// 문자열로 변환
    					byteBuffer.flip();
    					Charset charset = Charset.forName("UTF-8");
    					String data = charset.decode(byteBuffer).toString();
    
    					// 모든 클라이언트에게 보냄
    					for(Client client : connections) {
    						client.send(data);
    					}
    				} catch(Exception e) {
    					try {
                // 예외가 발생하면 connections 컬렉션에서 Client 객체를 제거
    						connections.remove(Client.this);
    						String message = "[ 클라이언트 통신 안됨 : " 
    								+ socketChannel.getRemoteAddress() + " : " 
    								+ Thread.currnetThread().getName() + " ]";
    						Platform.runLater(() -> displayText(message));
                // SocketChannel을 닫는다.
    						socketChannel.close();
    					} catch (IOException e2) {}
    					break;
    				}
    			}
    		}
    	};
      // 스레드풀에서 처리하기위해 submit()을 호출
      executorService.submit(runnable);
    }
    ```
    
- 데이터를 클라이언트로 보내는 `send()` 메소드
    - 스레드풀의 작업 스레드가 처리하도록 작업을 Runnable로 정의
    
    ```java
    void send(String data) {
      // 데이터를 클라이언트로 보내는 작업을 Runnable로 생성
    	Runnable runnable = new Runnable() {
        // run()을 재정의
    		@Override
    		public void run() {
    			try {
    				// 클라이언트로 보내기
    				Charset charset = Charset.forName("UTF-8");
            ByteBuffer byteBuffer = charset.encode(data);
            socketChannel.write(byteBuffer);
    			} catch(Exception e) {
    				try {
    					String message = "[ 클라이언트 통신 안됨 : "
                  + socketChannel.getRemoteAddress() + " : "
                  + Thread.currentThread().getName() + " ]";
              Platform.runLater(() -> displayText(message));
              // connections 컬렉션에서 예외가 발생한 Client를 제거
              connections.remove(Client.this);
              socketChannel.close();
    				} catch (IOException e2) {}
    			}
    		}
    	};
      // 스레드풀에서 처리
      executorService.submit(runnable);
    }
    ```
    

## 5. UI 생성 코드

- 프로그램적 레이아웃을 이용해서 컴포넌트를 배치
    
    ```java
    TextArea txtDisplay;
    Button btnStartStop;
    	
    @Override
    public void start(Stage primaryStage) throws Exception {
    	BorderPane root = new BorderPane();
    	root.setPrefSize(500, 300);
    		
    	txtDisplay = new TextArea();
    	txtDisplay.setEditable(false);
    	BorderPane.setMargin(txtDisplay, new Insets(0, 0, 2, 0));
    	root.setCenter(txtDisplay);
    		
    	btnStartStop = new Button("start");
    	btnStartStop.setPrefHeight(30);
    	btnStartStop.setMaxWidth(Double.MAX_VALUE);
    		
    	// start 버튼과 stop 버튼을 클릭했을 때 이벤트 처리
    	btnStartStop.setOnAction(e -> {
    		if(btnStartStop.getText().equals("start")) {
    			startServer();
    		} else if(btnStartStop.getText().equals("stop")) {
    			stopServer();
    		}
    	});
    	root.setBottom(btnStartStop);
    		
    	Scene scene = new Scene(root);
    	scene.getStylesheets().add(getClass().getResource("app.css").toString());
    	primaryStage.setScene(scene);
    	primaryStage.setTitle("Server");
    		
    	// 윈도우 우측 상단 닫기 버튼을 클릭했을 때 이벤트 처리
    	primaryStage.setOnCloseRequest(event -> stopServer());
    	primaryStage.show();
    }
    	
    // 작업 스레드의 작업 처리 내용을 출력할 때 호출되는 메소드
    void displayText(String text) {
    	txtDisplay.appendText(text + "\n");
    }
    	
    public static void main(String[] args) {
    	launch(args);
    }
    ```
    
    - app.css
        
        ![Untitled](/images/lang_java/NIO/채팅_서버_구현/Untitled.png)
        
    
    ```css
    /* text-area 배경색 */
    .text-area {
    	-fx-background-color : gold;
    }
    
    /* scroll-pane 배경색 */
    .text-area .scroll-pane {
    	-fx-background-color : transparent;
    }
    
    /* viewport 배경색 */
    .text-area .scroll-pane .viewport {
    	-fx-background-color : transparent;
    }
    
    /* content 배경색 */
    .text-area .scroll-pane .content {
    	-fx-background-color : transparent;
    }
    ```
    
    ![2023-02-03 01 18 55.gif](/images/lang_java/NIO/채팅_서버_구현/2023-02-03_01_18_55.gif)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판