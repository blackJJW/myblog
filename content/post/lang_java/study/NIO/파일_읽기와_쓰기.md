---
title: "[Java] NIO, AsynchronousFileChannel 파일 읽기와 쓰기"
description: ""
date: "2023-01-29T14:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"

---
<!--more-->

- AsynchronousFileChannel이 생성되었다면 `read()`, `write()` 메소드를 이용해서 입출력할 수 있다.
    
    ```java
    read(ByteBuffer dst, long position, 
         A attachment, CompletionHandler<Integer, A> handler);
    write(ByteBuffer src, long position,
          A attachment, CompletionHandler<Integer, A> handler);
    ```
    
    - 이 메소드들은 호출하면 즉시 리턴
        - 스레드풀의 스레드가 입출력 작업을 진행
    - dst와 src 매개값은 읽거나 쓰기 위한 ByteBuffer
    - position 매개값은 파일에서 읽을 위치이거나 쓸 위치
        - 파일의 첫 번째 바이트부터 읽거나 첫 번째 위치에 바이트를 쓰고 싶다면 position을 0으로 준다.
    - attachment 매개값은 콜백 메소드로 전달할 첨부 객체
        - 첨부 객체는 콜백 메소드에서 결과값 외에 추가적인 정보를 얻고자 할 때 사용하는 객체
        - 첨부 객체가 필요없다면 null을 대입
    - handler 매개값은 `CompletionHandler<Integer, A>` 구현 객체를 지정
        - Integer는 입출력 작업의 결과 타입
            - `read()`와 `write()`가 읽거나 쓴 바이트 수
        - A는 첨부 객체 타입
            - 개발자가 CompletionHandler 구현 객체를 작성할 때 임의로 지정이 가능
            - 만약 첨부 객체가 필요없다면 A는 Void가 된다.
- `CompletionHandler<Integer, A>` 구현 객체는 비동기 작업이 정상적으로 완료된 경우와 예외 발생으로 실패된 경우에 자동 콜백되는 다음 메소드를 가지고 있어야 한다.
    
    
    | 리턴 타입 | 메소드명(매개 변수) | 설명 |
    | --- | --- | --- |
    | void | completed(Integer result, A attachment) | 작업이 정상저으로 완료된 경우 콜백 |
    | void | failed(Throwable exc, A attachment) | 예외 때문에 작업이 실패된 경우 콜백 |
    - `completed()` 메소드의 result 매개값은 작업 결과가 대입
        - `read()`와 `write()` 작업 결과는 읽거나 쓴 바이트 수
    - attachment 매개값은 `read()`와 `write()` 호출 시 제공된 첨부 객체
    - `failed()` 메소드의 exc 매개값은 작업 처리 도중 발생한 예외
    - 콜백 메소드를 실행하는 스레드는 `read()`와 `write()`를 호출한 스레드가 아니고 스레드풀의 작업 스레드라는 것
        - JavaFX 애플리케이션일 경우 UI 생성 및 변경 작업을 이 메소드에서 직접할 수 없고 `Platform.runLater()`을 이용
    - CompletionHandler 구현 클래스를 작성하는 방법
        
        ```java
        new CompletionHandler<Integer, A>() {
        	@Override
        	public void comleted(Integer result, A attachment) {...}
        	@Override
        	public void failed(Throwable exc, A attachment) {...}
        }
        ```
        
- ex) AsynchronousFileChannel을 이용
    - 비동기적으로 “C:\Temp” 디렉토리에 file0.txt ~ file9.txt까지 총 10개의 파일을 생성한 후 “안녕하세요”라는 내용을 작성
    - 비동기 작업이 완료되었을 때 사용된 바이트 수와 처리를 담당했던 스레드 이름을 콘솔에 출력
    - AsychronousFileChannelWriteEx.java
    
    ```java
    import java.io.IOException;
    import java.nio.ByteBuffer;
    import java.nio.channels.AsynchronousFileChannel;
    import java.nio.channels.CompletionHandler;
    import java.nio.charset.Charset;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardOpenOption;
    import java.util.EnumSet;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    
    public class AsychronousFileChannelWriteEx {
    
    	public static void main(String[] args) throws Exception {
    		// 스레드풀 생성
    		ExecutorService executorService = Executors.newFixedThreadPool(
    					Runtime.getRuntime().availableProcessors()
    				);
    		
    		for(int i = 0; i < 10; i++) {
    			Path path = Paths.get("C:/Temp/file" + i + ".txt");
    			Files.createDirectories(path.getParent());
    			
    			// 비동기 파일 채널 생성
    			AsynchronousFileChannel fileChannel 
    					= AsynchronousFileChannel.open(
    							path,
    							EnumSet.of(StandardOpenOption.CREATE,
    									StandardOpenOption.WRITE),
    							executorService
    						);
    			
    			// 파일에 저장할 데이터를 ByteBuffer에 저장
    			Charset charset = Charset.defaultCharset();
    			ByteBuffer byteBuffer = charset.encode("안녕하세요");
    			
    			// 첨부 객체 생성
    			class Attachment {
    				Path path; // 파일 경로 저장
    				AsynchronousFileChannel fileChannel; // 비동기 파일 채널 저장
    			}
    			Attachment attachment = new Attachment();
    			attachment.path = path;
    			attachment.fileChannel = fileChannel;
    			
    			// CompletionHandler 객체 생성
    			CompletionHandler<Integer, Attachment> completionHandler 
    					= new CompletionHandler<Integer, Attachment>() {
    				@Override
    				public void completed(Integer result, Attachment attachement) {
    					System.out.println(attachment.path.getFileName() + " : " 
    							+ result + " bytes written : " 
    							+ Thread.currentThread().getName());
    					try { attachment.fileChannel.close(); } catch (IOException e) {}
    				}
    				@Override
    				public void failed(Throwable exc, Attachment attachment) {
    					exc.printStackTrace();
    					try { attachment.fileChannel.close(); } catch (IOException e) {}
    				}
    			}; 
    			
    			fileChannel.write(byteBuffer, 0, attachment, completionHandler);
    			            // 버퍼 객체, 버퍼 인덱스, 첨부 객체, 콜백 메소드를 가진 객체
    		}
    		
    		// 스레드풀 종료
    		Thread.sleep(100);
    		executorService.shutdown();
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/NIO/파일_읽기와_쓰기/Untitled.png)
    
    - `fileChannel.write(byteBuffer, 0, attachment, completionHandler);`에서 `write()` 메소드가 즉시 리턴되더라도 뒤에서는 작업 스레드가 파일 스레드가 파일 쓰기 작업을 하고 있기 때문에 바로 AsychronousFileChannel을 닫으면 안 된다.
    - 작업이 정상적으로 완료되었거나, 실패일 경우 채널을 닫아야 하므로 `completed()`와 `failed()` 메소드에서 AsychronousFileChannel의 `close()`를 호출해야 한다.
- ex) 생성한 file0.txt ~ file9.txt를 읽고 콘솔에 출력
    - AsynchronousFileChannelReadEx.java
    
    ```java
    import java.io.IOException;
    import java.nio.ByteBuffer;
    import java.nio.channels.AsynchronousFileChannel;
    import java.nio.channels.CompletionHandler;
    import java.nio.charset.Charset;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardOpenOption;
    import java.util.EnumSet;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    
    public class AsynchronousFileChannelReadEx {
    
    	public static void main(String[] args) throws Exception {
    		// 스레드풀 생성
    		ExecutorService executorService = Executors.newFixedThreadPool(
    					Runtime.getRuntime().availableProcessors()
    				);
    		
    		for(int i = 0; i < 10; i++) {
    			Path path = Paths.get("C:/Temp/file" + i + ".txt");
    			
    			// 비동기 파일 채널 생성
    			AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
    						path,
    						EnumSet.of(StandardOpenOption.READ),
    						executorService
    					);
    			
    			// 파일의 크기와 동일한 capacity를 갖는 버퍼 생성
    			ByteBuffer byteBuffer = ByteBuffer.allocate((int)fileChannel.size());
    			
    			// 첨부 객체 생성
    			class Attachment {
    				Path path; // 파일 경로 저장
    				AsynchronousFileChannel fileChannel; // 비동기 파일 채널 저장
    				ByteBuffer byteBuffer; // 읽은 데이터를 저장할 버퍼
    			}
    			Attachment attachment = new Attachment();
    			attachment.path = path;
    			attachment.fileChannel = fileChannel;
    			attachment.byteBuffer = byteBuffer;
    			
    			// CompletionHandler 객체 생성
    			CompletionHandler<Integer, Attachment> completionHandlernew 
    					= new CompletionHandler<Integer, Attachment>(){
    				@Override
    				public void completed(Integer result, Attachment attachment) {
    					attachment.byteBuffer.flip();
    					
    					// 버퍼에 저장된 데이터를 문자열로 복원
    					Charset charset = Charset.defaultCharset();
    					String data = charset.decode(attachment.byteBuffer).toString();
    					
    					System.out.println(attachment.path.getFileName() + " : "
    							+ data + " : "
    							+ Thread.currentThread().getName());
    					try { fileChannel.close(); } catch (IOException e) {}
    				}
    				@Override
    				public void failed(Throwable exc, Attachment attachment) {
    					exc.printStackTrace();
    					try { fileChannel.close(); } catch (IOException e) {}
    				}
    			};
    			
    			// 파일 읽기
    			fileChannel.read(byteBuffer, 0, attachment, completionHandlernew);
    			  // 읽은 데이터를 저장할 버퍼 객체, 버퍼 인덱스, 첨부 객체, 콜백 메소드를 가진 객체 
    		}
    		
    		// 스레드풀 종료
    		executorService.shutdown();
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/NIO/파일_읽기와_쓰기/Untitled%201.png)
    
    - `fileChannel.read(byteBuffer, 0, attachment, completionHandlernew);`의 `read()` 메소드가 즉시 리턴되더라도 뒤에서는 작업 스레드가 파일 읽기 작업을 하고 있다.
        - 바로 AsynchronousFileChannel을 닫으면 안 된다.
    - 작업이 정상적으로 완료되었거나, 실패일 경우 채널을 닫아야 하므로 `completed()`와 `failed()` 메소드에서 AsynchronousFileChannel의 `close()`를 호출해야 한다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판