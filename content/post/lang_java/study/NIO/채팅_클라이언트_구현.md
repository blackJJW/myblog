---
title: "[Java] NIO, TCP 블로킹 채널, 채팅 클라이언트 구현"
description: ""
date: "2023-02-03T21:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "JavaFX"
  - "Network"

---
<!--more-->

## 1. 클라이언트 클래스 구조

- ClientEx.java
    - 채팅 클라이언트
    
    ```java
    import java.nio.channels.SocketChannel;
    
    import javafx.application.Application;
    
    // JavaFX 메인 클래스로 만들기 위해 Application을 상속
    public class ClientEx extends Application {
    	SocketChannel socketChannel;
    	
    	void startClient() {
    		// 연결 시작 코드
    	}
    	
    	void stopClient() {
    		// 연결 끊기 코드
    	}
    	
    	void receive() {
    		// 데이터 받기 코드
    	}
    	
    	void send(String data) {
    		// 데이터 전송 코드
    	}
    	
    	//////////////////////////////////
    	// UI 생성 코드
    }
    ```
    
    - 실행 화면에서 [start] 버튼을 클릭하면 `startClient()` 메소드가 호출
        - [start] 버튼은 [stop] 버튼으로 변경
    - [stop] 버튼을 클릭하면 `stopClient()` 메소드가 호출
        - [stop] 버튼은 [start] 버튼으로 변경

## 2. `startClient()` 메소드

- [start] 버튼을 클릭하면 `startClient()` 메소드가 실행
    - `startClient()` 메소드에는 Socket 생성 및 연결 요청 코드가 있어야 한다.
    
    ```java
    void startClient() {
    	// 스레드 생성
    	/* 작업 스레드가 필요한 이유는 connect()와 
       * receive()에서 블로킹이 일어나기 때문
       * JavaFX Application Thread는 이 메소드들을 
       * 호출하지 않는 것이 좋다.
       */
    	Thread thread = new Thread() {
    		@Override
    		public void run() {
    			try {
    				// Socket 생성 및 연결 요청
            // 통신용 블로킹 SocketChannel을 생성
    				socketChannel = SocketChannel.open();
    				socketChannel.configureBlocking(true);
    				socketChannel.connect(new InetSocketAddress("localhost", 5001));
    				
            /* 작업 스레드는 UI를 변경하지 못하므로 
             * Platform.runLater()가 사용
             */
    				Platform.runLater(() -> {
    					try {
    						displayText("[ 연결 완료 : " 
    							+ socketChannel.getRemoteAddress() + " ]");
    						btnConn.setText("stop");
    						btnSend.setDisable(false);
    					} catch(Exception e) {}
    				});
    			} catch(Exception e) {
           /* 예외가 발생하면 [ 서버 통신 안됨 ]을 출력하도록
            * displayText()로 출력
            */
    				Platform.runLater(() -> displayText("[ 서버 통신 안됨 ]"));
    				if(socketChannel.isOpen()) { stopClient(); }
    				return; // return을 실행해서 스레드 종료
    			}
    			// 서버에서 보낸 데이터 받기
    			receive();
    		}
    	};
    	// 스레드 시작
    	thread.start();
    }
    ```
    

## 3. `stopClient()` 메소드

- [stop] 버튼을 클릭하거나, 서버 통신이 안 될 경우 `stopClient()` 메소드가 실행
    - SocketChannel을 닫는 `close()` 메소드 호출 코드가 있어야 한다.
    
    ```java
    void stopClient() {
    	try {
        // UI를 변경하기 위해 Platform.runLater()가 사용
    		Platform.runLater(() -> {
    			displayText("[ 연결 끊음 ]");
    			btnConn.setText("start");
    			btnSend.setDisable(true);
    		});
    
        /* socketChannel 필드가 null이 아니고
         * 현재 열려 있는 경우
         */
    		if(socketChannel != null && socketChannel.isOpen()) {
    			socketChannel.close(); // 연결 끊기
    		}
    	} catch (IOException e) {}
    }
    ```
    

## 4. `receive()` 메소드

- 서버에서 보낸 데이터를 받는 역할
    - `startClient()`에서 생성한 작업 스레드상에서 호출
    
    ```java
    void receive() {
    	while(true) { // 반복적으로 읽기 위해 무한 루프로 작성
    		try {
          /* 받은 데이터를 저장하기 위해 
           * 길이 100인 ByteBuffer를 생성
           */
    			ByteBuffer byteBuffer = ByteBuffer.allocate(100);
    
    			/* 서버가 비정상적으로 종료했을 경우
           * IOException 발생
           */
    			// 데이터 받기
          /* 서버가 데이터를 보내기 전까지 블로킹
           * 데이터를 받으면 byteBuffer에 저장한 후
           * 받은 데이터 개수를 readByteCount에 저장
           */
    			int readByteCount = socketChannel.read(byteBuffer);
    
    			// 서버가 정상적으로 Socket의 close()를 호출했을 경우
    			if(readByteCount == -1) {
    				throw new IOException();
    			}
    
    			// 문자열로 변환
          // flip() 메소드로 ByteBuffer의 위치 속성값 변경
          // UTF-8로 디코딩된 문자열을 얻는다. 
    			byteBuffer.flip();
    			Charset charset = Charset.forName("UTF-8");
    			String data = charset.decode(byteBuffer).toString();
    
    			Platform.runLater(() -> displayText("[ 받기 완료 ]" + data));
    		} catch (Exception e) {
    			Platform.runLater(() -> displayText("[ 서버 통신 안됨 ]"));
    			stopClient();
    			break; // 무한 루프 빠져나옴
    		}
    	}
    }
    ```
    

## 5. `send(String data)` 메소드

- 사용자가 메시지를 입력하고 [send] 버튼을 클릭하면 메시지를 매개값으로 해서 `send(String data)` 메소드가 호출
    - 메시지를 서버로 보내는 역할
    
    ```java
    void send(String data) {
    	// 스레드 생성
    	Thread thread = new Thread() {
    		@Override
    		public void run() {
    			try {
    				Charset charset = Charset.forName("UTF-8");
    				ByteBuffer byteBuffer = charset.encode(data);
    				
    				// 서버로 데이터 보내기
    				socketChannel.write(byteBuffer);
    				Platform.runLater(() -> displayText("[ 전송 완료 ]"));
    			} catch(Exception e) {
    				Platform.runLater(() -> displayText("[ 서버 통신 안됨 ]"));
    				stopClient();
    			}
    		}
    	};
    	thread.start(); // 스레드 시작
    }
    ```
    

## 6. UI 생성 코드

- 프로그램적 레이아웃 이용해서 컨트롤을 배치
    
    ```java
    TextArea txtDisplay;
    TextField txtInput;
    Button btnConn, btnSend;
    
    @Override
    public void start(Stage primaryStage) throws Exception {
    	BorderPane root = new BorderPane();
    	root.setPrefSize(500, 300);
    
    	txtDisplay = new TextArea();
    	txtDisplay.setEditable(false);
    	BorderPane.setMargin(txtDisplay, new Insets(0, 0, 2, 0));
    	root.setCenter(txtDisplay);
    
    	BorderPane bottom = new BorderPane();
    		txtInput = new TxtField();
    		txtInput.setPrefSize(60, 30);
    		BorderPane.setMargin(txtInput, new Isets(0, 1, 1, 1));
    
    		btnConn = new Button("start");
    		btnConn.setPrefSize(60, 30);
    		// start 버튼과 stop 버튼을 클릭했을 때 이벤트 처리
    		btnConn.setOnAction(e -> {
    			if(btnConn.getText().equals("start")) {
    				startClient();
    			} else if(btnConn.getText().equals("stop")) {
    				stopClient();
    			}
    		});
    
    		btnSend = new Button("send");
    		btnSend.setPrefSize(60, 30);
    		btnSend.setDisable(true);
    		// send 버튼을 클릭했을 때 이벤트 처리
    		btnSend.setOnAction(e -> send(txtInput.getText()));
    
    		bottom.setCenter(txtInput);
    		bottom.setLeft(btnConn);
    		bottom.setRight(btnSend);
    
    	root.setBottom(bottom);
    
    	Scene scene = new Scene(root);
    	scene.getStyleSheets().add(getClass().getResource("app.css").toString());
    	primaryStage.setScene(scene);
    	primaryStage.setTitle("Client");
      // 윈도우 우측 상단 닫기 버튼을 클릭했을 때 이벤트 처리
    	primaryStage.setOnCloseRequest(event -> stopClient());
    	primaryStage.show();
    }
    
    void displayText(String text) {
    	txtDisplay.appendText(text + "\n");
    }
    
    public void main(String[] args) {
    	launch(args);
    }
    ```
    

## 채팅 서버와 클라이언트를 실행하는 방법

- 서버인 ServerEx를 한 개, 클라이언트인 ClientEx를 두 개 실행
    
    ![Untitled](/images/lang_java/NIO/채팅_클라이언트_구현/Untitled.png)
    
- ServerEx의 [start] 버튼을 클릭하고 이어서 두 개의 ClientEx의 [start] 버튼을 각각 클릭
    - ServerEx에서 연결 개수가 2로 나오는 지 확인

![4.gif](/images/lang_java/NIO/채팅_클라이언트_구현/1.gif)
    
- 두 개의 ClientEx 입력란에 메시지를 입력하고 [send] 버튼을 클릭
    - 그 결과 ServerEx에서 요청 처리가 출력
    - 각각의 ClientEx에서 메시지가 출력

![2.gif](/images/lang_java/NIO/채팅_클라이언트_구현/2.gif)
    
- 첫 번째 ClientEx의 [stop] 버튼을 클릭
    - ClientEx에서 연결 끊음이 출력
    - ServerEx에서 클라이언트 통신 안됨이 출력

![3.gif](/images/lang_java/NIO/채팅_클라이언트_구현/3.gif)

- ServerEx의 [stop] 버튼을 클릭
    - ServerEx에서 서버 멈춤이 출력
    - 두 번째 ClientEx에서 서버 통신 안됨이 출력

![4.gif](/images/lang_java/NIO/채팅_클라이언트_구현/4.gif)

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판