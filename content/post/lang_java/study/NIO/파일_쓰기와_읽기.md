---
title: "[Java] NIO, FileChannel 파일 쓰기와 읽기"
description: ""
date: "2023-01-27T23:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"

---
<!--more-->

### 1. 파일 쓰기

- 파일에 바이트를 쓰려면 FileChannel의 `write()` 메소드를 호출
    - 매개값으로 ByteBuffer 객체를 주면 된다.
    - 파일에 쓰여지는 바이트는 ByteBuffer의 position부터 limit까지
    - position이 0이고 limit이 capacity와 동일하다면 ByteBuffer의 모든 바이트가 파일에 쓰여진다.
    - `write()` 메소드의 리턴값은 ByteBuffer에서 파일로 쓰여진 바이트 수
    
    ```java
    int bytesCount = fileChannel.write(ByteBuffer src);
    ```
    
- ex) FileChannel을 이용해서 문자열을 C:\Temp\file.txt 파일에 저장
    - FileChannelWriteEx.ajva
    
    ```java
    import java.io.IOException;
    import java.nio.ByteBuffer;
    import java.nio.channels.FileChannel;
    import java.nio.charset.Charset;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardOpenOption;
    
    public class FileChannelWriteEx {
    
    	public static void main(String[] args) throws IOException {
    		Path path = Paths.get("C:/Temp/file.txt");
    		Files.createDirectories(path.getParent());
    		
    		// FileChannel 생성
    		FileChannel fileChannel = FileChannel.open(
    				path,
    				StandardOpenOption.CREATE,
    				StandardOpenOption.WRITE
    				);
    		
    		String data = "안녕하세요";
    		Charset charset = Charset.defaultCharset();
    		ByteBuffer byteBuffer = charset.encode(data);
    		
    		// 파일에 데이터 쓰기
    		int byteCount = fileChannel.write(byteBuffer);
    		System.out.println("file.txt : " + byteCount + " bytes written");
    		
    		fileChannel.close();
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/NIO/파일_쓰기와_읽기/Untitled.png)
    

### 2. 파일 읽기

- 파일로부터 바이트를 읽기 위해서는 FileChannel의 `read()` 메소드를 호출
    - 매개값으로 ByteBuffer 객체를 준다.
    - 파일에서 읽혀지는 바이트는 ByteBuffer의 position부터 저장
    - position이 0이면 ByteBuffer의 첫 바이트부터 저장
    - `read()` 메소드의 리턴값은 파일에서 ByteBuffer로 읽혀진 바이트 수
    - 한 번 읽을 수 있는 최대 바이트수는 ByteBuffer의 capacity까지 리턴
        - 최대값은 capacity가 된다.
        - 더 이상 읽을 바이트가 없다면 `read()` 메소드는 -1을 리턴
    
    ```java
    int bytesCount = fileChannel.read(ByteBuffer dst);
    ```
    
- 버퍼에 한 바이트를 저장할 때마다 position이 1씩 증가
    - `read()` 메소드가 -1을 리턴할 때까지 버퍼에 저장한 마지막 바이트의 위치는 position-1 인덱스
- ex) C:\Temp\file.txt 파일을 읽고 콘솔에 출력
    - FileChannelReadEx.java
    
    ```java
    import java.io.IOException;
    import java.nio.ByteBuffer;
    import java.nio.channels.FileChannel;
    import java.nio.charset.Charset;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardOpenOption;
    
    public class FileChannelReadEx {
    
    	public static void main(String[] args) throws IOException {
    		Path path = Paths.get("C:/Temp/file.txt");
    		
    		// FileChannel 생성
    		FileChannel fileChannel = FileChannel.open(
    				path, 
    				StandardOpenOption.READ
    				);
    		
    		ByteBuffer byteBuffer = ByteBuffer.allocate(100);
    		
    		Charset charset = Charset.defaultCharset();
    		String data = "";
    		int byteCount;
    		
    		while(true) {
    			// 파일로부터 데이터 읽기
    			byteCount = fileChannel.read(byteBuffer);
    			if(byteCount == -1) break;
    			byteBuffer.flip();
    			data += charset.decode(byteBuffer).toString();
    			byteBuffer.clear();
    		}
    		
    		fileChannel.close();
    		System.out.println("file.txt : " + data);
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/NIO/파일_쓰기와_읽기/Untitled%201.png)
    
    - 파일의 크기가 100바이트보다 작지만 ByteBuffer의 크기를 100
    - FileChannel의 `read()` 메소드를 호출해서 최대 100바이트를 읽는다.
    - 파일의 크기가 100바이트보다 작으므로 byteCount에는 100보다 작은 값이 저장
    - `flip()`을 호출한 이유는 limit을 현재 position으로 설정하고 position을 0으로 설정하기 위함
    - `clear()`를 호출한 이유는 position을 0번 인덱스로, limit을 capacity로 설정해서 ByteBuffer를 초기화하기 위함

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판