---
title: "[Java] NIO, TCP 블로킹 채널, 소켓 채널 데이터 통신"
description: ""
date: "2023-01-30T21:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
  - "Network"

---
<!--more-->

- 클라이언트가 연결 요청(`connect()`)하고 서버가 연결 수락(`accept()`) 했을 경우
    - 양쪽 SocketChannel 객체의 `read()`, `write()` 메소드를 호출해서 데이터 통신을 할 수 있다.
    - 이 메소드들은 모두 버퍼를 이용하기 때문에 버퍼로 읽고, 쓰는 작업을 해야 한다.
    
    ![Untitled](/images/lang_java/NIO/소켓_채널_데이터_통신/Untitled.png)
    
- SocketChannel의 `write()` 메소드를 이용해서 문자열을 보내는 코드
    
    ```java
    Charset charset = Charset.forName("UTF-8");
    ByteBuffer byteBuffer = charset.encode("Hello Server");
    socketChannel.write(byteBuffer);
    ```
    
- SocketChannel의 `read()` 메소드를 이용해서 문자열을 받는 코드
    
    ```java
    ByteBuffer byteBuffer = ByteBuffer.allocate(100);
    int byteCount = socketChannel.read(byteBuffer);
    byteBuffer.flip();
    Charset charset = Charset.forName("UTF-8");
    String message = charset.decode(byteBuffer).toString();
    ```
    
- ex) 연결 성공 후
    1. 클라이언트가 먼저 “Hello Server”를 보낸다.
    2. 서버가 이 데이터를 받는다.
    3. “Hello Client”를 클라이언트로 보낸다.
    4. 클라이언트가 이 데이터를 받는다.
    - ClientEx.java
    
    ```java
    import java.io.IOException;
    import java.net.InetSocketAddress;
    import java.nio.ByteBuffer;
    import java.nio.channels.SocketChannel;
    import java.nio.charset.Charset;
    
    public class ClientEx {
    
    	public static void main(String[] args) {
    		SocketChannel socketChannel = null;
    		try {
    			socketChannel = SocketChannel.open();
    			socketChannel.configureBlocking(true);
    			System.out.println("[ 연결 요청 ]");
    			socketChannel.connect(new InetSocketAddress("localhost", 5001));
    			System.out.println("[ 연결 성공 ]");
    			
    			ByteBuffer byteBuffer = null;
    			Charset charset = Charset.forName("UTF-8");
    			
    			// 1.
    			byteBuffer = charset.encode("Hello Server");
    			socketChannel.write(byteBuffer);
    			System.out.println("[ 데이터 보내기 성공 ]");
    			
    			// 4.
    			byteBuffer = ByteBuffer.allocate(100);
    			int byteCount = socketChannel.read(byteBuffer);
    			byteBuffer.flip();
    			String message = charset.decode(byteBuffer).toString();
    			System.out.println("[ 데이터 받기 성공 ] : " + message);
    		} catch(Exception e) {}
    		
    		if(socketChannel.isOpen()) {
    			try {
    				socketChannel.close();
    			} catch(IOException e1) {}
    		}
    	}
    }
    ```
    
    - ServerEx.java
    
    ```java
    import java.io.IOException;
    import java.net.InetSocketAddress;
    import java.nio.ByteBuffer;
    import java.nio.channels.ServerSocketChannel;
    import java.nio.channels.SocketChannel;
    import java.nio.charset.Charset;
    
    public class ServerEx {
    
    	public static void main(String[] args) {
    		ServerSocketChannel serverSocketChannel = null;
    		try {
    			serverSocketChannel = ServerSocketChannel.open();
    			serverSocketChannel.configureBlocking(true);
    			serverSocketChannel.bind(new InetSocketAddress(5001));
    			while(true) {
    				System.out.println("[ 연결 기다림 ]");
    				SocketChannel socketChannel = serverSocketChannel.accept();
    				InetSocketAddress isa = (InetSocketAddress) socketChannel.getRemoteAddress();
    				System.out.println("[ 연결 수락함 ] " + isa.getHostName());
    				
    				ByteBuffer byteBuffer = null;
    				Charset charset = Charset.forName("UTF-8");
    				
    				// 2.
    				byteBuffer = ByteBuffer.allocate(100);
    				int byteCount = socketChannel.read(byteBuffer);
    				byteBuffer.flip();
    				String message = charset.decode(byteBuffer).toString();
    				System.out.println("[ 데이터 받기 성공 ] : " + message);
    				
    				// 3.
    				byteBuffer = charset.encode("Hello Client");
    				socketChannel.write(byteBuffer);
    				System.out.println("[ 데이터 보내기 성공 ]");
    			}
    		} catch(Exception e) {}
    		
    		if(serverSocketChannel.isOpen()) {
    			try {
    				serverSocketChannel.close();
    			} catch (IOException e1) {}
    		}
    	}
    }
    ```
    
    - ServerEx부터 먼저 실행하고 ClientEx을 실행
    
    ![Untitled](/images/lang_java/NIO/소켓_채널_데이터_통신/Untitled%201.png)
    
- 데이터를 받기 위해 `read()` 메소드를 호출하면 상대방이 데이터를 보내기 전까지는 블로킹(blocking)된다.
    - `read()` 메소드가 블로킹 해제되고 리턴되는 경우는 다음 세 가지
    
    | 블로킹이 해제되는 경우 | 리턴값 |
    | --- | --- |
    | 상대방이 데이터를 보냄 | 읽은 바이트 수 |
    | 상대방이 정상적으로 SocketChannel의 close()를 호출 | -1 |
    | 상대방이 비정상적으로 종료 | IOException 발생 |
- 상대방이 정상적으로 SocketChannel의 `close()`를 호출하고 연결을 끊었을 경우와 상대방이 비정상적으로 종료된 경우
    - 예외 처리를 해서 이쪽도 SocketChannel을 닫기 위해 `close()` 메소드를 호출해야 한다.
    
    ```java
    try {
    	...
    	// 상대방이 비정상적으로 종료했을 경우 IOException 발생
    	int byteCount = socketChannel.read(byteBuffer);
    
    	// 상대방이 정상적으로 Socket의 close()를 호출했을 경우
    	if(readByteCount == -1) {
    		throw new IOException(); // 강제적으로 IOException 발생시킴
    	}
    	...
    } catch (Exception e) {
    	try { socketChannel.close(); } catch(Exception e2) {}
    }
    ```
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판