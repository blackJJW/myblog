---
title: "[Java] NIO 소개"
description: ""
date: "2023-01-23T13:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"
---
<!--more-->

- 새로운 입출력(NIO : New Input/Output)이라는 뜻
    - `java.nio` 패키지에 포함
    
    ### NIO에서 제공하는 패키지
    
    | NIO 패키지 | 포함되어 있는 내용 |
    | --- | --- |
    | java.nio | 다양한 버퍼 클래스 |
    | java.nio.channels | 파일 채널, TCP 채널, UDP 채널 등의 클래스 |
    | java.nio.channels.spi | java.nio.channels 패키지를 위한 서비스 제공자 클래스 |
    | java.nio.charset | 문자셋, 인코더, 디코더 API |
    | java.nio.charset.spi | java.nio.charset 패키지를 위한 서비스 제공자 클래스 |
    | java.nio.file | 파일 및 파일 시스템에 접근하기 위한 클래스 |
    | java.nio.file.attribute | 파일 및 파일 시스템의 속성에 접근하기 위한 클래스 |
    | java.nio.file.spi | java.nio.file 패키지를 위한 서비스 제공자 클래스  |

# 1. IO와 NIO의 차이점

- IO와 NIO는 데이터를 입력한다는 목적은 동일
    - 방식에 있어서 큰게 차이가 있다.
    
    ### IO와 NIO의 차이점
    
    | 구분 | IO | NIO |
    | --- | --- | --- |
    | 입출력 방식 | 스트림 방식 | 채널 발식 |
    | 버퍼 방식 | 넌버퍼(non-buffer) | 버퍼(buffer) |
    | 비동기 방식 | 지원 안 함 | 지원 |
    | 블로킹 / 넌블로킹 방식 | 블로킹 방식만 지원 | 블로킹 / 넌블로킹 방식 모두 지원 |

## 1.1 스트림 채널 vs. 채널

- IO는 스트림(Stream) 기반
    - 스트림은 입력 스트림과 출력 스트림으로 구분
        - 데이터를 읽기 위해서는 입력 스트림을 생성
        - 데이터를 출력하기 위해서는 출력 스트림을 생성
    
    ex) 하나의 파일에서 데이터를 읽고 저장하는 작업을 모두 해야 한다면 FileInputStream과 FileOutputStream을 별도로 저장
    
- NIO는 채널(Channel) 기반
    - 채널은 스트림과 달리 양방향으로 입력과 출력이 가능
        - 입력과 출력을 위한 별도의 채널을 만들 필요가 없다.
    
    ex) 하나의 파일에서 데이터를 읽고 저장하는 작업을 모두 해야 한다면 FileChannel 하나만 생성
    

## 1.2 넌버퍼 vs. 버퍼

- IO에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽는다.
    - 이런 시스템은 대체로 느리다.
    - 버퍼(Buffer : 메모리 저장소)를 사용해서 복수 개의 바이트를 한꺼번에 입력받고 출력하는 것이 빠른 성능을 낸다.
        - IO는 버퍼를 제공해주는 보조 스트림인 BufferedInputStream, BufferedOutputStream을 연결해서 사용하기도 한다.
- NIO는 기본적으로 버퍼를 사용해서 입출력을 하기 때문에 IO보다는 입출력 성능이 좋다.
    - 채널은 버퍼에 저장된 데이터를 출력
    - 입력된 데이터를 버퍼에 저장
    
    ![Untitled](/images/lang_java/NIO/NIO_소개/Untitled.png)
    
- IO는 스트림에서 읽은 데이터를 즉시 처리
    - 스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않을 경우
        - 입력된 데이터의 위치를 이동해 가면서 자유롭게 이용할 수 없다.
- NIO는 읽은 데이터를 무조건 버퍼에 저장하기 때문에 버퍼 내에서 데이터의 위치를 이동해 가면서 필요한 부분만 읽고 쓸 수 있다.

## 1.3 블로킹 vs. 넌블로킹

- IO는 블로킹(blocking)된다.
    - 입력 스트림의 `read()` 메소드를 호출하면 데이터가 입력되기 전까지 스레드는 블로킹(대기 상태)된다.
    - 출력 스트림의 `write()` 메소드를 호출하면 데이터가 출력되기 전까지 스레드는 블로킹된다.
    - IO 스레드가 블로킹되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트(interrupt)도 할 수 없다.
    - 블로킹을 빠져나오는 유일한 방법은 스트림을 닫는 것
- NIO는 블로킹과 넌블로킹(non-blocking) 특징을 모두 가지고 있다.
    - IO 블로킹과의 차이점은 NIO 블로킹은 스레드를 인터럽트함으로써 빠져나올 수가 있다는 것
    - 블로킹의 반대 개념이 넌블로킹
        - 입출력 작업 시 스레드가 블로킹되지 않는 것을 말함
    - NIO의 넌블로킹은 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하기 때문에 작업 스레드가 블로킹되지 않는다.
        - 준비가 완료 : 지금 바로 읽고 쓸 수 있는 상태
    - NIO 넌블로킹의 핵심 객체는 멀티플렉서(multiplexor)인 셀렉터(Selector)
        - 셀렉터는 복수 개의 채널 중에서 준비 완료된 채널을 선택하는 방법을 제공

# 2. IO와 NIO의 선택

- 네트워크 프로그램을 개발할 때 IO와 NIO 선택 기준
    - NIO
        - 불특정 다수의 클라이언트 연결 또는 멀티 파일들을 넌블로킹이나 비동기로 처리 가능
        - 과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용한다는 점에서 큰 장점
        - 운영체제의 버퍼(다이렉트 버퍼)를 이용한 입출력이 가능하기 때문에 입출력 성능이 향상
- NIO는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우에 사용하는 것이 좋다.
    - 스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업의 수가 늘어나기 때문에 제한된 스레드로 처리하는 것이 오히려 불리할 수 있다.
- 대용량 데이터를 처리할 경우에는 IO가 더 유리
    - NIO는 버퍼의 할당 크기가 문제
        - 모든 입출력 작업에 버퍼를 무조건 사용해야 하므로 받은 즉시 처리하는 IO보다는 좀 더 복잡
    - 연결 클라이언트 수가 적고, 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있을 경우에는 IO로 서버를 구현하는 것이 좋다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판