---
title: "[Java] NIO, 버퍼"
description: ""
date: "2023-01-24T10:00:30+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"

---
<!--more-->

- NIO에서는 데이터를 입출력하기 위해 항상 버퍼를 사용해야 한다.
- 버퍼는 읽고 쓰기가 가능한 메모리 배열
    
    ![Untitled](/images/lang_java/NIO/버퍼/Untitled.png)
    

## 1. Buffer 종류

- Buffer는 저장되는 데이터 타입에 따라 분류될 수 있다.
- 어떤 메모리를 사용하느냐에 따라 다이렉트(Direct)와 넌다이렉트(NonDirect)로 분류할 수도 있다.

### 1.1 데이터 타입에 따른 버퍼

- NIO 버퍼는 저장되는 데이터 타입에 따라서 별도의 클래스로 제공
    - 이 버퍼 클래스들은 Buffer 추상 클래스를 모두 상속
    
    ![Untitled](/images/lang_java/NIO/버퍼/Untitled%201.png)
    
    - 버퍼 클래스의 이름을 보면 어떤 데이터가 저장되는 버퍼인지 알 수 있다.
    - MappedByteBuffer는 ByteBuffer의 하위 클래스로 파일의 내용에 랜덤하게 접근하기 위해서 파일의 내용을 메모리와 맵핑시킨 버퍼

### 1.2 넌다이렉트와 다이렉트 버퍼

- 버퍼가 사용하는 메모리의 위치에 따라서 넌다이렉트(non-direct) 버퍼와 다이렉트(direct) 버퍼로 분류
    - 넌다이렉트 버퍼 : JVM이 관리하는 힙 메모리 공간을 이용하는 버퍼
    - 다이렉트 버퍼 : 운영체제가 관리하는 메모리 공간을 이용하는 버퍼
    
    | 구분 | 넌다이렉트 버퍼 | 다이렉트 버퍼 |
    | --- | --- | --- |
    | 사용하는 메모리 공간 | JVM의 힙 메모리 | 운영체제의 메모리 |
    | 버퍼 생성 시간 | 버퍼 생성이 빠르다. | 버퍼 생성이 느리다. |
    | 버퍼의 크기 | 작다. | 크다.(큰 데이터를 처리할 때 유리) |
    | 입출력 성능 | 낮다. | 높다.(입출력이 빈번할 때 유리) |
    - 넌다이렉트 버퍼
        - JVM 힙 메모리를 사용하므로 버퍼 생성 시간이 빠르다.
        - JVM의 제한된 힙 메모리를 사용하므로 버퍼의 크기를 크게 잡을 수 없다.
        - 입출력을 하기 위해 임시 다이렉트 버퍼를 생성하고 넌다이렉트 버퍼에 있는 내용을 임시 다이렉트 버퍼에 복사
            - 그리고 나서 임시 다이렉트 버퍼를 사용해서 운영체제의 native I/O 기능을 수행
            - 직접 다이렉트 버퍼를 사용하는 것보다는 입출력 성능이 낮다.
    - 다이렉터 버퍼
        - 운영체제의 메모리를 할당받기 위해 운영체제의 네이티브(native) C 함수를 호출해야 하고 여러 가지 처리를 해야 하므로 상대적으로 버퍼 생성이 느리다.
            - 자주 생성하기 보다는 한 번 생성해 놓고 재사용하는 것이 적합
        - 운영체제가 관리하는 메모리를 사용하므로 운영체제가 허용하는 범위 내에서 대용량 버퍼를 생성시킬 수 있다.
- ex) 컴퓨터에서 200MB 크기의 버퍼를 생성
    - 다이렉트 버퍼는 정상적으로 생성
    - 넌다이렉트 버퍼는 OutOfMemoryError가 발생할 수도 있음
    - 컴퓨터의 성능과 현재 상태에 따라서 버퍼의 크기가 유동적이기 때문에 크기를 조정하면서 테스트
    - 사용된 버퍼 ByteBuffer
    - `allocate()` 메소드는 넌다이렉트 버퍼를 생성하는 메소드
    - `allocateDirect()` 메소드는 다이렉트 버퍼를 생성하는 메소드
    - BufferSizeEx.java
    
    ```java
    import java.nio.ByteBuffer;
    
    public class BufferSizeEx {
    
    	public static void main(String[] args) {
    		ByteBuffer directBuffer = ByteBuffer.allocateDirect(200 * 1024 * 1024);
    		System.out.println("다이렉트 버퍼가 생성됨");
    		
    		ByteBuffer nonDirectBuffer = ByteBuffer.allocate(200 * 1024 * 1024);
    		System.out.println("넌다이렉트 버퍼가 생성됨");
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/NIO/버퍼/Untitled%202.png)
    
- ex) 넌다이렉트 버퍼와 다이렉트 버퍼의 성능 테스트 결과를 출력
    - 이미지 파일을 100번 복사하는데 걸린 시간을 측정
        - 다이렉트 버퍼가 훨씬 빠름
    - PerformanceEx.java
    
    ```java
    import java.nio.ByteBuffer;
    import java.nio.channels.FileChannel;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardOpenOption;
    import java.util.EnumSet;
    
    public class PerformaceEx {
    
    	public static void main(String[] args) throws Exception {
    		Path from = Paths.get("src/buffer/p-1.png");
    		Path to1 = Paths.get("src/buffer/p-2.png");
    		Path to2 = Paths.get("src/buffer/p-3.png");
    		
    		long size = Files.size(from);
    		
    		FileChannel fileChannel_from = FileChannel.open(from);
    		FileChannel fileChannel_to1 = FileChannel.open(to1,
    				EnumSet.of(StandardOpenOption.CREATE,
    						StandardOpenOption.WRITE));
    		FileChannel fileChannel_to2 = FileChannel.open(to2,
    				EnumSet.of(StandardOpenOption.CREATE,
    						StandardOpenOption.WRITE));
    		
    		// 다이렉트와 넌다이렉트 버퍼 생성
    		ByteBuffer nonDirectBuffer = ByteBuffer.allocate((int) size);
    		ByteBuffer directBuffer = ByteBuffer.allocateDirect((int) size);
    		
    		long start, end;
    		
    		// 넌다이렉트 버퍼 테스트
    		start = System.nanoTime();
    		for(int i = 0; i < 100; i++) {
    			fileChannel_from.read(nonDirectBuffer);
    			nonDirectBuffer.flip();
    			fileChannel_to1.write(nonDirectBuffer);
    			nonDirectBuffer.clear();
    		}
    		end = System.nanoTime();
    		System.out.println("non-Direct : \t" + (end - start) + " ns");
    		
    		// 파일의 위치를 0으로 설정(처음으로 돌림)
    		fileChannel_from.position(0);
    		
    		// 다이렉트 버퍼 테스트
    		start = System.nanoTime();
    		for(int i = 0; i < 100; i++) {
    			fileChannel_from.read(directBuffer);
    			nonDirectBuffer.flip();
    			fileChannel_to1.write(directBuffer);
    			nonDirectBuffer.clear();
    		}
    		end = System.nanoTime();
    		System.out.println("Direct : \t" + (end - start) + " ns");
    		
    		fileChannel_from.close();
    		fileChannel_to1.close();
    		fileChannel_to2.close();
    	}
    }
    ```
    
    ![Untitled](/images/lang_java/NIO/버퍼/Untitled%203.png)
    
- 다이렉트 버퍼는 채널(Channel)을 사용해서 버퍼의 데이터를 읽고 저장할 경우에만 운영체제의 native I/O를 수행
- 만약 채널을 사용하지 않고 ByteBuffer의 `get()`/`put()` 메소드를 사용해서 버퍼의 데이터를 읽고, 저장할 경우
    - 이 작업은 내부적으로 JNI를 호출해서 native I/O를 수행하기 때문에 JNI 호출이라는 오버헤드가 추가된다.
        - JNI(Java Native Interface) : 자바 코드에서 C함수를 호출할 수 있도록 해주는 API
    - 그렇기 때문에 넌다이렉트 버퍼의 `get()`/`put()` 성능이 더 좋게 나올 수도 있다.

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판