---
title: "[Java] 어노테이션"
description: ""
date: "2022-07-29T17:00:45+09:00"
thumbnail: ""
categories:
  - "Java"
tags:
  - "Java"


---
<!--more-->

- 어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다.
- 메타데이터
    - 애플리케이션이 처리해야할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것이지를 알려주는 정보
- 어노테이션의 형태
    
    ```java
    @AnnotationName
    ```
    

### 어노테이션의 세 가지 용도

- 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
    - 대표적인 예
        - `@Override` 어노테이션
            - 메소드 선언 시 사용
            - 메소드가 오버라이드(재정의)된 것임을 컴파일러에게 알려주어 컴파일러가 오버라이드 검사를 하도록 해준다.
            - 정확히 오버라이드가 되지 않았다면 컴파일러는 에러를 발생시킨다.
- 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
- 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

---

- 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 배포를 위해 JAR 압축 파일을 생성하는 데에도 사용
- 실행 시 클래스의 역할을 정의하기도 한다.

# 어노테이션 타입 정의와 적용

---

- 어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사
- `@interface`를 사용해서 어노테이션을 정의하며, 그 뒤에 사용할 어노테이션 이름이 온다.
    
    ```java
    public @interface AnnotationName {
    
    }
    ```
    
    이렇게 정의한 어노테이션은 코드에서 다음과 같이 사용
    
    ```java
    @AnnotationName
    ```
    
- 어노테이션은 엘리먼트(element)를 멤버로 가질 수 있다.
    - 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.
    
    ```java
    public @interface AnnotationName {
    	타입 elementName() [default 값]; // 엘리먼트 선언
    	...
    }
    ```
    
    - 엘리먼트의 타입
        - int, double과 같은 기본 데이터 타입
        - String 타입
        - 열거 타입
        - Class 타입
        - 배열 타입
        
        엘리먼트의 이름 뒤에는 메소드를 작성하는 것처럼 `()`를 붙어야 한다.
        
        - ex) String 타입의 엘리먼트와 int 타입의 엘리먼트 선언
            
            ```java
            public @interface AnnotationName {
            	String elementName1();
            	int elementName2() default 5;
            }
            ```
            
            - 이렇게 정의한 어노테이션을 코드에서 적용
                
                ```java
                @AnnotationName(elementName1="값", elementName2=3);
                
                또는
                
                @AnnotationName(elementName1="값");
                ```
                
            - elementName1은 디폴트 값이 없기 때문에 반드시 값을 기술해야하고, elementName2는 디폴트 값이 있기 때문에 생략 가능
                - 어노테이션은 기본 엘리멘트인 value를 가질 수 있다.
                
                ```java
                public @interface AnnotationName {
                	String value();  // 기본 엘리먼트 선언
                	int elementName() default 5;
                }
                ```
                
            - Value 엘리먼트를 가진 어노테이션을 코드에서 적용
                - 이 값은 기본 엘리먼트인 value 값으로 자동 설정
                
                ```java
                @AnnotationName("값");
                ```
                
            - value 엘리먼트와 다른 엘리먼트의 값을 동시에 주고 싶다면 다음과 같이 정상적인 방법으로 지정
                
                ```java
                @AnnotationName(value="값", elementName=3);
                ```
                

# 어노테이션 적용 대상

---

- 어노테이션을 적용할 수 있는 대상은 `java.lang.annotation.ElementType` 열거 상수로 다음과 같이 정의
    
    ![Untitled](/images/lang_java/class/어노테이션/Untitled.png)
    
- 어노테이션이 적용될 대상을 지정할 때에는 `@Target` 어노테이션을 사용
    - `@Target`의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다.
    - 어노테이션이 적용될 대상을 복수 개로 지정하기 위해서이다.
    - ex) 어노테이션을 정의
        
        ```java
        @Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
        public @interface AnnotationName {
        
        }
        ```
        
        - 다음과 같이 클래스, 필드, 메소드만 어노테이션을 적용할 수 있고 생성자는 적용 불가
        
        ```java
        @AnnotationName
        public class ClassName {
        	@AnnotationName
        	private String fieldName;
        
        	//@AnnotationName // (x) -> @Target에 CONSTRUCT가 없어 생성자는 적용 못함
        	public ClassName() {}
        
        	@AnnotationName
        	public void methodName() {}
        }
        ```
        

# 어노테이션 유지 정책

---

- 어노테이션 정의 시 한 가지 더 추가해야할 내용
    - 사용 용도에 따라 `@AnnotationName`을 어느 범위까지 유지할 것인지 지정
    - 소스상에만 유지할 건지, 컴파일된 클래스까지 유지할 건지, 런타임 시에도 유지할 건지를 지정
- 어노테이션 유지 정책은 `java.lang.annoatation.Retention.Policy` 열거 상수로 다음과 같이 정의되어 있다.
    
    ![Untitled](/images/lang_java/class/어노테이션/Untitled%201.png)
    

### 리플렉션(Reflection)

- 런타임 시에 클래스의 메타 정보를 얻는 기능
- ex) 클래스가 가지고 있는 필드가 무엇인지, 어떤 생성자를 갖고 있는지, 적용된 어노테이션이 무엇인지 알아내는 것이 리플렉션

---

- 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻으려면 어노테이션 유지 정책을 `RUNTIME`으로 설정해야 한다.
- 어노테이션 유지 정책을 지정할 때에는 `@Retention` 어노테이션을 사용
    - `@Retention`의 기본 엘리먼트인 value는 RetentionPolicy 타입이므로 위 세 가지 상수 중 하나를 지정하면 된다.
- 코드 자동 생성 툴을 개발하지 않는 이상 우리가 작성하는 어노테이션은 대부분 런타임 시점에 사용하기 위한 용도로 만들어진다.
    - ex) 런타임 유지 정책을 적용한 어노테이션
        
        ```java
        @Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
        @Retention(RetentionPolicy.RUNTIME)
        public @interface AnnotationName {
        
        }
        ```
        

# 런타임 시 어노테이션 정보 사용하기

---

- 런타임 시에 어노테이션이 적용되었는지 확인하고 엘리먼트 값을 이용해서 특정 작업을 수행하는 방법
- 어노테디션 자체는 아무런 동작을 가지지 않는 단지 표식일 뿐이지만, 리플렉션을 이요해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다.
- 클래스에 적용된 어노테이션 정보를 얻으려면 `java.lang.Class`를 이용하면 되지만, 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class의 다음 메소드를 통해서 `java.lang.reflect` 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 한다.
    
    ![Untitled](/images/lang_java/class/어노테이션/Untitled%202.png)
    
- 그런 다음 Class, Field, Constructor, Method가 가지고 있는 다음 메소드를 호출해서 적용된 어노테이션 정보를 얻을 수 있다.
    
    ![Untitled](/images/lang_java/class/어노테이션/Untitled%203.png)
    

### 예제

- PrintAnnotation.java
    - 어노테이션 정의
    - 각 메소드의 실행 내용을 구분선으로 분리해서 콘솔에 출력
    
    ```java
    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;
    
    @Target({ElementType.METHOD})
    @Retention(RetentionPolicy.RUNTIME)
    
    public @interface PrintAnnotation {
    	String value() default "-";
    	int number() default 15;
    }
    ```
    
    - `@Target`은 메소드에만 적용
    - `@Retention`은 런타임 시까지 어노테이션 정보를 유지
    - 기본 엘리먼트 value는 구분선에 사용될 문자
    - number는 반복 출력 횟수
    - 디폴트 값은 각각 “-”와 15
- service.java
    - 어노테이션 적용 클래스
    
    ```java
    public class Service {
    	@PrintAnnotation
    	public void method1() {
    		System.out.println("실행 내용1");
    	}
    	
    	@PrintAnnotation("*")
    	public void method2() {
    		System.out.println("실행 내용2");
    	}
    	
    	@PrintAnnotation(value="#", number=20)
    	public void method3() {
    		System.out.println("실행 내용3");
    	}
    }
    ```
    
- PrintAnnotationEx.java
    - 리플랙션을 이용해서 Service 클래스에 적용된 어노테이션 정보를 읽고 렐리먼트 값에 따라 출력할 문자와 출력 횟수를 콘솔에 출력한 후, 해당 메소드를 출력
    - method, invoke(new Service())는 Service 객체를 생성, 생성된 Service 객체의 메소드를 호출하는 코드
    
    ```java
    import java.lang.reflect.Method;
    
    public class PrintAnnotationEx {
    
    	public static void main(String[] args) {
    		// Service 클래스로부터 메소드 정보를 얻음
    		Method[] declaredMethods = Service.class.getDeclaredMethods();
    		                           // Service 클래스에 선언된 메소드 얻기(리플렉션)
    		// Method 객체를 하나씩 처리
    		for(Method method : declaredMethods) {
    			// PrintAnnotation이 적용되었는지 확인
    			if(method.isAnnotationPresent(PrintAnnotation.class)) {
    				// PrintAnnotation 객체 얻기
    				PrintAnnotation printAnnotation = method.getAnnotation(PrintAnnotation.class);
    			
    				// 메소드 이름 출력
    				System.out.println("[ " + method.getName() + " ] ");
    			
    				// 구분선 출력
    				for(int i = 0; i <printAnnotation.number(); i++) {
    					System.out.print(printAnnotation.value());
    				}
    				System.out.println();
    			
    				try {
    					// 메소드 출력
    					method.invoke(new Service());
    				} catch(Exception e) {}
    				System.out.println();
    			}
    		}
    	}	
    }
    ```
    
    ![Untitled](/images/lang_java/class/어노테이션/Untitled%204.png)
    

---

## References

- 이것이 자바다 신용권의 Java 프로그래밍 정복 - 신용권 지음, 한빛미디어 출판